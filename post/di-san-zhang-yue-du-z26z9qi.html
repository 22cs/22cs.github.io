<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name=robots content="noindex, nofollow"><title>第三章阅读 | 我的个人博客</title><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css integrity=sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js integrity=sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><link rel=stylesheet href=/css/main.min.b5407e444443caa6fa0312456fd1cef3711a9a4d60e9289f2b963407a3fd45fa.css><link rel="shortcut icon" href=/favicon.ico><script defer src=/js/search.min.1cc2fbf876687993a3d29c47a92c0f79cded21086cb04efa8408befa1182bb41.js></script></head><body class=post-template><div class=container><nav><ul class=navigation-menu><li class=navigation-menu-item><a href=/>首页</a></li><li class=navigation-menu-item><a href=/archives/>归档</a></li><li class=navigation-menu-item><a href=/tags/>标签</a></li><li class=navigation-menu-item><a href=/categories/>分类</a></li><li class="navigation-menu-item search-toggle"><a href=#search>搜索</a></li></ul></nav><div id=search-container class=search-container><div class=search-box><input type=text id=search-input placeholder=搜索文章... autofocus>
<button id=search-close>×</button></div><div id=search-results class=search-results></div></div><main><article class=post><header><h1 class=post-title>第三章阅读</h1><div class=meta><time class=post-date datetime=2025-04-09>2025年04月09日</time></div></header><section class=post-content><p><strong>AI评估的章节目录与学习优先级:</strong></p><ul><li><p>3.1 引言 <strong>[P3 - Supplementary]</strong></p></li><li><p>3.2 加法和减法 <strong>[P1 - Core]</strong></p></li><li><p>3.3 乘法 <strong>[P1 - Core]</strong></p><ul><li>3.3.1 顺序乘法算法及硬件 <strong>[P1 - Core]</strong></li><li>3.3.2 有符号乘法 <strong>[P2 - Important]</strong></li><li>3.3.3 更快速的乘法 <strong>[P2 - Important]</strong></li><li>3.3.4 LEGv8 中的乘法 <strong>[P2 - Important]</strong></li><li>3.3.5 小结 <strong>[P3 - Supplementary]</strong></li></ul></li><li><p>3.4 除法 <strong>[P1 - Core]</strong></p><ul><li>3.4.1 除法算法及硬件 <strong>[P1 - Core]</strong></li><li>3.4.2 有符号除法 <strong>[P2 - Important]</strong></li><li>3.4.3 更快速的除法 <strong>[P2 - Important]</strong></li><li>3.4.4 LEGv8 中的除法 <strong>[P2 - Important]</strong></li><li>3.4.5 小结 <strong>[P3 - Supplementary]</strong></li></ul></li><li><p>3.5 浮点运算 <strong>[P1 - Core]</strong></p><ul><li>3.5.1 浮点表示 <strong>[P1 - Core]</strong></li><li>3.5.2 异常和中断 <strong>[P2 - Important]</strong></li><li>3.5.3 IEEE 754 浮点标准 <strong>[P1 - Core]</strong></li><li>3.5.4 浮点加法 <strong>[P1 - Core]</strong></li><li>3.5.5 浮点乘法 <strong>[P1 - Core]</strong></li><li>3.5.6 LEGv8 中的浮点指令 <strong>[P2 - Important]</strong></li><li>3.5.7 算术精确性 <strong>[P2 - Important]</strong></li><li>3.5.8 小结 <strong>[P3 - Supplementary]</strong></li></ul></li><li><p>3.6 并行与计算机算术：子字并行 <strong>[P2 - Important]</strong></p></li><li><p>3.7 实例： x86 中的流处理 SIMD 扩展和高级向量扩展 <strong>[P3 - Supplementary]</strong></p></li><li><p>3.8 实例：其他的 ARMv8 算术指令 <strong>[P3 - Supplementary]</strong></p><ul><li>3.8.1 完整的 ARMv8 整数和浮点算术指令 <strong>[P3 - Supplementary]</strong></li><li>3.8.2 完整的 ARMv8 SIMD 指令 <strong>[P3 - Supplementary]</strong></li></ul></li><li><p>3.9 加速：子字并行和矩阵乘法 <strong>[P2 - Important]</strong></p></li><li><p>3.10 谬误与陷阱 <strong>[P3 - Supplementary]</strong></p></li><li><p>3.11 本章小结 <strong>[P3 - Supplementary]</strong></p></li><li><p>3.12 历史观点与拓展阅读 <strong>[P3 - Supplementary]</strong></p></li><li><p>3.13 练习题 <strong>[P3 - Supplementary]</strong></p></li></ul><hr><p><strong>技术核心学习与思维导图构建指南 (任务列表)</strong></p><p><strong>思维导图根节点:</strong> Ch3: 计算机算术运算 ⭐⭐⭐</p><p><strong>3.1 引言 [P3 - Supplementary]</strong></p><ul><li><strong>学习任务:</strong> 识别本章核心议题（计算机如何执行算术运算，包括整数和浮点数）及解决的关键问题（如实数表示、大数处理、乘除法硬件实现）。</li><li><strong>Mind Map 构建建议:</strong> 在根节点下创建分支 &ldquo;3.1 引言 [P3] ⭐"，备注 &ldquo;核心议题：整数/浮点运算实现&rdquo;。</li></ul><p><strong>3.2 加法和减法 [P1 - Core]</strong></p><ul><li><p><strong>学习任务:</strong></p><ul><li><p><strong>机制:</strong> 精确描述二进制按位加法的过程，特别是进位 (Carry) 的产生和逐位传递逻辑。</p></li><li><p><strong>机制:</strong> 详解二进制减法如何通过加法（具体是加上减数的二进制补码）来实现。推导并理解 <code>A - B = A + (-B)</code>​ 在补码体系下的运算过程。</p></li><li><p><strong>核心概念:</strong> 定义溢出 (Overflow)。</p></li><li><p><strong>核心原理:</strong> 彻底理解有符号数加减法发生溢出的<strong>充要条件</strong> (参考图 3-2)。务必解释清楚：</p><ul><li>为何两个正数相加结果为负时发生溢出？（涉及向符号位的进位）</li><li>为何两个负数相加结果为正时发生溢出？（涉及向符号位的进位）</li><li>为何一个正数减去一个负数结果为负时发生溢出？（等价于正+正=负）</li><li>为何一个负数减去一个正数结果为正时发生溢出？（等价于负+负=正）</li><li>为何符号不同的数相加 或 符号相同的数相减 <strong>永不</strong> 发生溢出？</li></ul></li><li><p><strong>机制:</strong> 硬件如何检测这些溢出条件？（通常检查操作数符号和结果符号，或检查符号位的进位/借位）。</p></li><li><p><strong>概念:</strong> 无符号数加减溢出条件是什么？（结果超出了表示范围）。为何地址计算中的无符号溢出通常可以被忽略？</p></li><li><p><strong>机制:</strong> 饱和运算 (Saturating Operation) 的精确定义是什么？它如何处理溢出情况（钳位到最大/最小值）？对比与二进制补码的环绕 (wrap-around) 行为。思考其在媒体处理（如音量控制）中的适用性。</p></li><li><p><strong>(P2 关联)</strong> 超前进位加法器 (Carry Lookahead Adder) 的基本思想是什么？（并行计算进位以加速）它与简单逐位进位加法器的主要性能权衡是什么？（速度 vs 硬件复杂度，关联附录A.6）。</p></li></ul></li><li><p><strong>Mind Map 构建建议:</strong></p><ul><li><p>创建主分支 &ldquo;3.2 加法与减法 [P1] ⭐⭐⭐ / 红色&rdquo;。</p></li><li><p>子分支 &ldquo;⚙️ 二进制加法&rdquo;: 记录按位规则、进位传递。</p></li><li><p>子分支 &ldquo;⚙️ 二进制减法&rdquo;: 核心节点，记录通过 &ldquo;加补码&rdquo; 实现，展示 <code>A + (~B + 1)</code>​。</p></li><li><p>核心节点 &ldquo;⚠️ 溢出 (Overflow)&rdquo;:</p><ul><li>子分支 &ldquo;💡 定义&rdquo;。</li><li>子分支 &ldquo;有符号溢出条件&rdquo;: 详细列出图 3-2 的四种情况及其原因（符号变化、符号位进/借位）。用 🔗 连接到补码运算。</li><li>子分支 &ldquo;硬件检测机制&rdquo;。</li><li>子分支 &ldquo;无符号溢出条件&rdquo;: 记录范围，解释地址计算忽略原因。</li></ul></li><li><p>子分支 &ldquo;⚙️ 饱和运算&rdquo;: 记录定义（钳位）、对比补码环绕、应用场景 (媒体)。</p></li><li><p>(可选 P2 关联) 子分支 &ldquo;💡 超前进位加法器&rdquo;: 记录基本思想（并行进位）、性能权衡（速度 vs 复杂度）。</p></li></ul></li></ul><p><strong>3.3 乘法 [P1 - Core]</strong></p><ul><li><p><strong>学习任务:</strong></p><ul><li><strong>基础:</strong> 理解 n 位乘以 m 位结果需要 n+m 位才能保证不丢失信息。在定长（如 64 位）运算中，这意味着什么？（可能发生溢出，或需要特殊指令处理高位结果）。</li><li><strong>术语:</strong> 区分被乘数 (Multiplicand)、乘数 (Multiplier)、积 (Product)。</li></ul></li><li><p><strong>Mind Map 构建建议:</strong> 创建主分支 &ldquo;3.3 乘法 [P1] ⭐⭐⭐ / 红色&rdquo;。记录术语，记录位数关系 <code>n*m -> n+m</code>​ 位。</p></li></ul><p><strong>3.3.1 顺序乘法算法及硬件 [P1 - Core]</strong></p><ul><li><p><strong>学习任务:</strong></p><ul><li><p><strong>核心算法 (图 3-4):</strong> 彻底分解“纸笔”乘法算法的三个核心步骤：</p><ol><li>检查乘数最低位：决定是否将被乘数加到当前的部分积上。</li><li>左移被乘数：为下一次可能的加法做准备（相当于乘以 2）。</li><li>右移乘数：处理下一位乘数。</li></ol><ul><li>理解这三步如何模拟手动乘法的逐位乘、移位和累加过程。</li></ul></li><li><p><strong>硬件演进 (图 3-3 vs 图 3-5):</strong></p><ul><li><strong>结构 V1 (图 3-3):</strong> 分析其组件（128 位被乘数寄存器、128 位 ALU、128 位积寄存器、64 位乘数寄存器）。理解为何需要 128 位宽度（被乘数需要左移 64 次）。分析其数据流。</li><li><strong>结构 V2 (图 3-5):</strong> 分析其改进：被乘数寄存器和 ALU 减半 (64 位)，积寄存器右移而不是被乘数左移，乘数寄存器合并到积寄存器的右半部分。理解这些改进为何能减少硬件资源且功能等价。思考其潜在的性能优势（如减少数据通路延迟）。</li></ul></li><li><p><strong>模拟:</strong> 必须手动模拟一个简单的乘法（如书中的 4 位 0010 x 0011），精确跟踪图 3-4 算法下各个寄存器（被乘数、乘数、积）在<strong>每一步</strong>之后的值。</p></li></ul></li><li><p><strong>Mind Map 构建建议:</strong></p><ul><li>在 &ldquo;3.3 乘法&rdquo; 下创建子分支 &ldquo;3.3.1 顺序算法与硬件 [P1] ⭐⭐⭐ / 红色&rdquo;。</li><li>核心节点 &ldquo;⚙️ 核心算法 (图 3-4)&rdquo;: 列出 3 个步骤并解释目的。</li><li>子分支 &ldquo;⚙️ 硬件 V1 (图 3-3)&rdquo;: 记录组件、位宽（强调 128 位原因）、数据流。</li><li>子分支 &ldquo;⚙️ 硬件 V2 (图 3-5)&rdquo;: 记录改进点（64 位 ALU/被乘数、积右移、乘数合并）、优势（资源、性能）。</li><li>子分支 &ldquo;📊 4位模拟 (0010x0011)&rdquo;: 详细记录每步寄存器值变化。</li></ul></li></ul><p><strong>3.3.2 有符号乘法 [P2 - Important]</strong></p><ul><li><p><strong>学习任务:</strong></p><ul><li><strong>方法1 (转换+符号):</strong> 理解最简单的处理方式：先将操作数转为正数，执行无符号乘法，最后根据原始符号决定结果符号（同号为正，异号为负）。</li><li><strong>方法2 (直接算法):</strong> 了解更高级的算法（如 Booth 算法，虽然书中未详述）可以直接处理补码。理解当使用类似顺序算法处理有符号数时，移位需要是<strong>算术右移</strong>（符号扩展）而不是逻辑右移。</li></ul></li><li><p><strong>Mind Map 构建建议:</strong></p><ul><li>在 &ldquo;3.3 乘法&rdquo; 下创建子分支 &ldquo;3.3.2 有符号乘法 [P2] ⭐⭐ / 橙色&rdquo;。</li><li>记录 &ldquo;方法1: 转换+定符号&rdquo;。</li><li>记录 &ldquo;方法2: 直接算法要点&rdquo;: 需要算术移位。</li></ul></li></ul><p><strong>3.3.3 更快速的乘法 [P2 - Important]</strong></p><ul><li><p><strong>学习任务:</strong></p><ul><li><strong>核心思想 (并行加法):</strong> 理解加速乘法的关键在于并行处理多个部分积的相加，而不是顺序累加。</li><li><strong>机制 (多加法器):</strong> 理解图 3-7 的基本结构：为乘数的每一位（或多位）设置加法器，并行计算部分积，然后通过树状结构（或阵列）快速将它们相加。对比与顺序算法的延迟差异（log2(n) vs n）。</li><li><strong>技术 (进位保留加法器):</strong> 了解进位保留加法器 (Carry Save Adder, CSA) 可以进一步加速并行加法过程（将进位传播延迟到最后一步）。</li></ul></li><li><p><strong>Mind Map 构建建议:</strong></p><ul><li>在 &ldquo;3.3 乘法&rdquo; 下创建子分支 &ldquo;3.3.3 快速乘法 [P2] ⭐⭐ / 橙色&rdquo;。</li><li>核心节点 &ldquo;💡 核心思想&rdquo;: 并行加法。</li><li>子分支 &ldquo;⚙️ 机制 (图 3-7)&rdquo;: 多加法器阵列/树，延迟对比 (log2(n) vs n)。</li><li>子分支 &ldquo;💡 进位保留加法器 (CSA)&rdquo;: 记录作用（延迟进位传播）。</li></ul></li></ul><p><strong>3.3.4 LEGv8 中的乘法 [P2 - Important]</strong></p><ul><li><p><strong>学习任务:</strong></p><ul><li><p><strong>指令:</strong> 掌握 LEGv8 提供的核心乘法指令：</p><ul><li>​<code>MUL Rd, Rn, Rm</code>​: 计算 64 位乘积（结果的低 64 位）。</li><li>​<code>SMULH Rd, Rn, Rm</code>​: 计算有符号乘积的高 64 位。</li><li>​<code>UMULH Rd, Rn, Rm</code>​: 计算无符号乘积的高 64 位。</li></ul></li><li><p><strong>应用:</strong> 理解程序员需要根据操作数类型（有符号/无符号）和所需结果（完整 128 位或低 64 位）选择合适的指令。</p></li><li><p><strong>溢出检测:</strong> 理解这些指令本身不设置溢出标志，需要软件通过检查高 64 位 (<code>SMULH</code>​/<code>UMULH</code>​ 的结果) 来判断 64 位乘法是否溢出。精确描述如何根据高 64 位判断有符号/无符号溢出。</p></li></ul></li><li><p><strong>Mind Map 构建建议:</strong></p><ul><li>在 &ldquo;3.3 乘法&rdquo; 下创建子分支 &ldquo;3.3.4 LEGv8 乘法指令 [P2] ⭐⭐ / 橙色&rdquo;。</li><li>记录指令 <code>MUL</code>​, <code>SMULH</code>​, <code>UMULH</code>​ 及其功能。</li><li>记录 &ldquo;⚠️ 溢出检测&rdquo;: 软件负责，描述如何通过检查高 64 位进行判断。</li></ul></li></ul><p><strong>3.3.5 小结 [P3 - Supplementary]</strong></p><ul><li><strong>学习任务:</strong> 快速回顾乘法核心思想（移位和加）及优化方向（并行）。</li><li><strong>Mind Map 构建建议:</strong> 在 &ldquo;3.3 乘法&rdquo; 下创建子分支 &ldquo;3.3.5 小结 [P3] ⭐"，链接回顾核心算法和优化思想节点。</li></ul><p><strong>3.4 除法 [P1 - Core]</strong></p><ul><li><p><strong>学习任务:</strong></p><ul><li><strong>基础:</strong> 理解除法是乘法的逆运算，但更复杂，且存在特殊情况（除零）。</li><li><strong>术语:</strong> 区分被除数 (Dividend)、除数 (Divisor)、商 (Quotient)、余数 (Remainder)。掌握核心关系式：<code>被除数 = 商 × 除数 + 余数</code>​，以及 <code>0 &lt;= |余数| &lt; |除数|</code>​，且余数符号通常与被除数一致。</li></ul></li><li><p><strong>Mind Map 构建建议:</strong> 创建主分支 &ldquo;3.4 除法 [P1] ⭐⭐⭐ / 红色&rdquo;。记录术语和核心关系式。</p></li></ul><p><strong>3.4.1 除法算法及硬件 [P1 - Core]</strong></p><ul><li><p><strong>学习任务:</strong></p><ul><li><p><strong>核心算法 (恢复余数法, 图 3-9):</strong> 彻底分解基本的二进制除法算法步骤：</p><ol><li><p><strong>尝试减:</strong> 余数寄存器减去除数寄存器。</p></li><li><p><strong>判断与置商:</strong></p><ul><li>如果结果非负 (余数 >= 0)，说明够减，商对应位置 1。</li><li>如果结果为负 (余数 &lt; 0)，说明不够减，商对应位置 0，并且 <strong>必须恢复余数</strong> (将除数加回去)。</li></ul></li><li><p><strong>移位:</strong> 除数寄存器右移（或余数/商寄存器左移，取决于硬件实现），为处理下一位做准备。</p></li></ol></li><li><p><strong>硬件结构 (图 3-8, 图 3-11):</strong></p><ul><li><strong>结构 V1 (图 3-8):</strong> 分析其组件（128 位除数寄存器、128 位 ALU、128 位余数寄存器、64 位商寄存器）。理解除数为何需要 128 位并右移。</li><li><strong>结构 V2 (图 3-11):</strong> 分析其改进（64 位 ALU/除数、余数寄存器左移、商寄存器合并到余数右半部分）。理解与乘法硬件的相似性。</li></ul></li><li><p><strong>模拟:</strong> 必须手动模拟一个简单的除法（如书中的 7 / 2，即 0111 / 0010），精确跟踪图 3-9 算法下各个寄存器（余数、除数、商）在<strong>每一步</strong>之后的值，特别注意余数恢复步骤。理解为何需要 n+1 (或 65) 次迭代。</p></li></ul></li><li><p><strong>Mind Map 构建建议:</strong></p><ul><li>在 &ldquo;3.4 除法&rdquo; 下创建子分支 &ldquo;3.4.1 顺序算法与硬件 [P1] ⭐⭐⭐ / 红色&rdquo;。</li><li>核心节点 &ldquo;⚙️ 核心算法 (恢复余数法, 图 3-9)&rdquo;: 列出 3 个步骤，强调第 2 步的判断、置商和 <strong>恢复</strong> 操作。</li><li>子分支 &ldquo;⚙️ 硬件 V1 (图 3-8)&rdquo;: 记录组件、位宽、数据流。</li><li>子分支 &ldquo;⚙️ 硬件 V2 (图 3-11)&rdquo;: 记录改进点、与乘法硬件相似性。</li><li>子分支 &ldquo;📊 4位模拟 (0111/0010)&rdquo;: 详细记录每步寄存器值变化，突出恢复步骤。</li></ul></li></ul><p><strong>3.4.2 有符号除法 [P2 - Important]</strong></p><ul><li><p><strong>学习任务:</strong></p><ul><li><strong>商的符号:</strong> 理解处理方法：先按绝对值进行除法，然后根据原始操作数符号决定商的符号（同号为正，异号为负）。</li><li><strong>余数的符号 (关键):</strong> 掌握余数符号的约定：与被除数符号保持一致。理解这个约定的原因是为了保证 <code>被除数 = 商 × 除数 + 余数</code>​ 关系的一致性，并避免商的绝对值随符号变化。通过 +/-7 除以 +/-2 的例子来验证该约定。</li></ul></li><li><p><strong>Mind Map 构建建议:</strong></p><ul><li>在 &ldquo;3.4 除法&rdquo; 下创建子分支 &ldquo;3.4.2 有符号除法 [P2] ⭐⭐ / 橙色&rdquo;。</li><li>记录 &ldquo;商符号规则&rdquo;。</li><li>核心节点 &ldquo;⚠️ 余数符号规则&rdquo;: 记录约定（同被除数），解释原因（保持公式一致性）。</li></ul></li></ul><p><strong>3.4.3 更快速的除法 [P2 - Important]</strong></p><ul><li><p><strong>学习任务:</strong></p><ul><li><strong>挑战:</strong> 理解为何除法比乘法更难并行加速（每步需要知道前一步减法结果的符号）。</li><li><strong>技术 (SRT 除法):</strong> 了解 SRT 除法的基本思想：通过查找表根据除数和当前余数的高位来<strong>预测</strong>多位商，允许后续步骤修正错误预测。了解这是现代处理器常用的技术。</li><li><strong>(P3 关联)</strong> 了解非恢复余数除法 (Non-restoring) 和不执行除法 (Non-performing) 作为替代算法的基本思路（避免显式恢复步骤）。</li></ul></li><li><p><strong>Mind Map 构建建议:</strong></p><ul><li>在 &ldquo;3.4 除法&rdquo; 下创建子分支 &ldquo;3.4.3 快速除法 [P2] ⭐⭐ / 橙色&rdquo;。</li><li>记录 &ldquo;加速挑战&rdquo; (依赖性)。</li><li>核心节点 &ldquo;💡 SRT 除法&rdquo;: 记录基本思想（查表预测多位商、可修正）。</li><li>(可选 P3 关联) 备注其他算法：非恢复、不执行。</li></ul></li></ul><p><strong>3.4.4 LEGv8 中的除法 [P2 - Important]</strong></p><ul><li><p><strong>学习任务:</strong></p><ul><li><p><strong>指令:</strong> 掌握 LEGv8 提供的核心除法指令：</p><ul><li>​<code>SDIV Rd, Rn, Rm</code>​: 有符号除法 (结果为商)。</li><li>​<code>UDIV Rd, Rn, Rm</code>​: 无符号除法 (结果为商)。</li></ul></li><li><p><strong>余数获取:</strong> 理解 LEGv8 (以及 ARMv8) 没有直接计算余数的指令，需要通过 <code>商 = 被除数 / 除数</code>​, <code>余数 = 被除数 - 商 * 除数</code>​ 的计算序列来获得。</p></li><li><p><strong>异常处理:</strong> 理解除法指令本身不处理除零或溢出（商太大无法表示），需要软件在执行除法前检查除数是否为零，以及执行后（如果需要）检查溢出。</p></li></ul></li><li><p><strong>Mind Map 构建建议:</strong></p><ul><li>在 &ldquo;3.4 除法&rdquo; 下创建子分支 &ldquo;3.4.4 LEGv8 除法指令 [P2] ⭐⭐ / 橙色&rdquo;。</li><li>记录指令 <code>SDIV</code>​, <code>UDIV</code>​ 及其功能（只得商）。</li><li>记录 &ldquo;余数获取方法&rdquo;: 通过公式计算。</li><li>记录 &ldquo;⚠️ 异常处理&rdquo;: 软件负责检查除零、溢出。</li></ul></li></ul><p><strong>3.4.5 小结 [P3 - Supplementary]</strong></p><ul><li><strong>学习任务:</strong> 快速回顾除法硬件与乘法相似，加速方法与挑战。</li><li><strong>Mind Map 构建建议:</strong> 在 &ldquo;3.4 除法&rdquo; 下创建子分支 &ldquo;3.4.5 小结 [P3] ⭐"，链接回顾核心算法、硬件相似性、加速挑战节点。</li></ul><p><strong>3.5 浮点运算 [P1 - Core]</strong></p><ul><li><p><strong>学习任务:</strong></p><ul><li><strong>动机:</strong> 理解需要浮点数来表示实数（带小数的数）以及非常大或非常小的数。</li><li><strong>核心概念 (科学记数法):</strong> 理解二进制科学记数法 <code>±1.fraction × 2^exponent</code>​ 的形式。</li><li><strong>核心概念 (规格化):</strong> 理解规格化 (Normalized) 的含义（小数点左边只有一位非零数字，在二进制中即为 1），及其优点（简化交换、简化算法、提高精度）。</li><li><strong>术语:</strong> 区分尾数 (Fraction/Mantissa) 和有效位 (Significand，包含隐含的 1 和尾数)。区分指数 (Exponent)。</li></ul></li><li><p><strong>Mind Map 构建建议:</strong> 创建主分支 &ldquo;3.5 浮点运算 [P1] ⭐⭐⭐ / 红色&rdquo;。记录动机、二进制科学记数法、规格化定义与优点、术语。</p></li></ul><p><strong>3.5.1 浮点表示 [P1 - Core]</strong></p><ul><li><p><strong>学习任务:</strong></p><ul><li><strong>核心权衡 (精度 vs. 范围):</strong> 理解在固定字长（如 32/64 位）下，分配给尾数的位数和分配给指数的位数之间存在根本性的权衡：更多尾数位提高精度，更多指数位扩大表示范围。关联“设计原则3: 好的设计需要好的权衡”。</li><li><strong>单精度 (Single Precision / float):</strong> 掌握其 32 位格式：1 位符号 (S)，8 位指数 (E)，23 位尾数 (F)。</li><li><strong>双精度 (Double Precision / double):</strong> 掌握其 64 位格式：1 位符号 (S)，11 位指数 (E)，52 位尾数 (F)。理解其主要优势在于更高的精度，其次是更大的范围。</li><li><strong>表示的值 (初步):</strong> 理解基本形式 <code>(-1)^S × Significand × 2^Exponent</code>​。注意此时还未引入隐含位和偏置指数。</li></ul></li><li><p><strong>Mind Map 构建建议:</strong></p><ul><li>在 &ldquo;3.5 浮点运算&rdquo; 下创建子分支 &ldquo;3.5.1 浮点表示 [P1] ⭐⭐⭐ / 红色&rdquo;。</li><li>核心节点 &ldquo;⚖️ 权衡&rdquo;: 精度 (尾数位数) vs. 范围 (指数位数)。</li><li>子分支 &ldquo;💡 单精度 (32位)&rdquo;: 记录格式 S(1) E(8) F(23)。</li><li>子分支 &ldquo;💡 双精度 (64位)&rdquo;: 记录格式 S(1) E(11) F(52)，记录主要优势（精度）。</li></ul></li></ul><p><strong>3.5.2 异常和中断 [P2 - Important]</strong></p><ul><li><p><strong>学习任务:</strong></p><ul><li><p><strong>浮点异常:</strong> 理解浮点运算中可能出现的异常情况：</p><ul><li>上溢 (Overflow): 正指数太大，超出指数表示范围。</li><li>下溢 (Underflow): 负指数的绝对值太大，超出指数表示范围。</li></ul></li><li><p><strong>处理机制:</strong> 理解发生异常时，处理器通常能产生异常 (Exception) 或中断 (Interrupt)，保存出错指令地址，并跳转到特定的处理程序。了解这是操作系统或运行时环境处理错误的基础。</p></li></ul></li><li><p><strong>Mind Map 构建建议:</strong></p><ul><li>在 &ldquo;3.5 浮点运算&rdquo; 下创建子分支 &ldquo;3.5.2 浮点异常 [P2] ⭐⭐ / 橙色&rdquo;。</li><li>记录 &ldquo;⚠️ 上溢 (Overflow)&rdquo; 定义。</li><li>记录 &ldquo;⚠️ 下溢 (Underflow)&rdquo; 定义。</li><li>记录 &ldquo;⚙️ 处理机制&rdquo;: 异常/中断，保存 PC，跳转处理程序。</li></ul></li></ul><p><strong>3.5.3 IEEE 754 浮点标准 [P1 - Core]</strong></p><ul><li><p><strong>学习任务:</strong></p><ul><li><p><strong>核心特性1 (隐含前导 1):</strong> 深刻理解规格化浮点数的有效位 (Significand) 等于 <code>1 + Fraction</code>​。这个 &lsquo;1&rsquo; 是隐含的，不存储在尾数字段中，从而有效增加了一位精度（单精度 23+1=24 位，双精度 52+1=53 位）。理解为何 0 没有隐含 1（因为 0 的指数和尾数全为 0）。</p></li><li><p><strong>核心特性2 (偏置指数):</strong></p><ul><li><strong>动机:</strong> 理解引入偏置 (Bias) 的主要目的是使得指数部分的比较可以直接使用无符号整数比较器（即指数大的浮点数其指数部分编码也更大），便于排序等操作。避免负指数的补码表示带来的比较复杂性。</li><li><strong>机制:</strong> 掌握指数的实际值 = 存储的指数值 - 偏置值。</li><li><strong>偏置值:</strong> 记住单精度偏置为 127，双精度偏置为 1023。</li></ul></li><li><p><strong>最终表示公式:</strong> 整合上述特性，掌握 IEEE 754 浮点数的精确表示公式：<code>(-1)^S × (1 + Fraction) × 2^(Exponent - Bias)</code>​ (适用于规格化数)。</p></li><li><p><strong>核心特性3 (特殊值):</strong> 理解 IEEE 754 使用特定的指数和尾数模式来表示特殊值：</p><ul><li><strong>±0:</strong> 指数全 0，尾数全 0。</li><li><strong>±Infinity (无穷):</strong> 指数全 1，尾数全 0。（用于表示除零结果或溢出）</li><li><strong>NaN (Not a Number):</strong> 指数全 1，尾数非 0。（用于表示无效操作结果，如 0/0, ∞-∞）</li><li><strong>(P3 关联)</strong> 非规格化数 (Denormals): 指数全 0，尾数非 0。（用于表示接近 0 的极小数，提供渐进下溢）</li></ul></li><li><p><strong>编码图 (图 3-13):</strong> 能够根据 S, E, F 的值判断表示的是 0、规格化数、非规格化数、无穷还是 NaN。</p></li><li><p><strong>示例转换:</strong> 必须能够手动将简单的十进制小数（如 -0.75）转换为 IEEE 754 单/双精度二进制表示，反之亦然。</p></li></ul></li><li><p><strong>Mind Map 构建建议:</strong></p><ul><li><p>在 &ldquo;3.5 浮点运算&rdquo; 下创建核心子分支 &ldquo;3.5.3 IEEE 754 标准 [P1] ⭐⭐⭐ / 红色&rdquo;。</p></li><li><p>核心节点 &ldquo;💡 隐含前导 1&rdquo;: 解释机制 <code>Significand = 1 + Fraction</code>​，记录增加的精度，说明 0 的特殊性。</p></li><li><p>核心节点 &ldquo;💡 偏置指数&rdquo;: 解释动机（简化比较），记录机制 <code>实际指数 = 存储值 - Bias</code>​，记录偏置值 (127/1023)。</p></li><li><p>核心节点 &ldquo;📐 最终表示公式&rdquo;: 记录 <code>(-1)^S * (1 + F) * 2^(E - Bias)</code>​。</p></li><li><p>核心节点 &ldquo;💡 特殊值编码 (图 3-13)&rdquo;:</p><ul><li>子分支 &ldquo;±0&rdquo; (E=0, F=0)。</li><li>子分支 &ldquo;±Infinity&rdquo; (E=max, F=0)。</li><li>子分支 &ldquo;NaN&rdquo; (E=max, F≠0)。</li><li>(可选 P3 关联) 子分支 &ldquo;Denormals&rdquo; (E=0, F≠0)。</li></ul></li><li><p>子分支 &ldquo;📊 示例转换&rdquo;: 记录手动转换步骤 (如 -0.75)。</p></li></ul></li></ul><p><strong>3.5.4 浮点加法 [P1 - Core]</strong></p><ul><li><p><strong>学习任务:</strong></p><ul><li><p><strong>核心算法 (图 3-14):</strong> 彻底掌握浮点加法的四个核心步骤：</p><ol><li><p><strong>指数对齐:</strong> 找出指数较大的数，将指数较小的数的有效位（Significand）<strong>右移</strong>，直到两数指数相同。理解移位会损失精度。</p></li><li><p><strong>有效位相加:</strong> 将对齐后的有效位相加。</p></li><li><p><strong>结果规格化:</strong></p><ul><li>可能需要<strong>右移</strong>（如果和导致最高位进位，如 9.999 + 0.016 = 10.015 -> 1.0015）并增加指数。</li><li>可能需要<strong>左移</strong>（如果相减导致前导零，如 1.000 - 0.111 = 0.001 -> 1.000）并减少指数。</li><li>检查规格化后的指数是否上溢或下溢。</li></ul></li><li><p><strong>舍入 (Rounding):</strong> 将规格化后的结果舍入到目标精度。注意舍入可能导致再次需要规格化（步骤 3）。</p></li></ol></li><li><p><strong>符号处理:</strong> 理解和的符号由有效位相加的结果自然确定。</p></li><li><p><strong>硬件结构 (图 3-15):</strong> 理解浮点加法单元的基本组成部分：指数比较器、多路选择器、有效位移位器、有效位加法器、规格化逻辑、舍入逻辑。能够将算法步骤对应到硬件单元。</p></li><li><p><strong>模拟:</strong> 必须手动模拟一个简单的浮点加法（如书中的 0.5 + (-0.4375)），精确跟踪算法的每一步，包括指数对齐、有效位相加、规格化和舍入。</p></li></ul></li><li><p><strong>Mind Map 构建建议:</strong></p><ul><li>在 &ldquo;3.5 浮点运算&rdquo; 下创建核心子分支 &ldquo;3.5.4 浮点加法 [P1] ⭐⭐⭐ / 红色&rdquo;。</li><li>核心节点 &ldquo;⚙️ 核心算法 (图 3-14)&rdquo;: 详细列出 4 个步骤，对规格化（左右移、溢出检查）和舍入（可能需再次规格化）进行重点解释。</li><li>子分支 &ldquo;符号确定&rdquo;: 由有效位相加结果决定。</li><li>子分支 &ldquo;⚙️ 硬件结构 (图 3-15)&rdquo;: 记录主要组件及其功能，与算法步骤对应。</li><li>子分支 &ldquo;📊 模拟 (0.5 + (-0.4375))&rdquo;: 详细记录每步计算结果。</li></ul></li></ul><p><strong>3.5.5 浮点乘法 [P1 - Core]</strong></p><ul><li><p><strong>学习任务:</strong></p><ul><li><p><strong>核心算法 (图 3-16):</strong> 掌握浮点乘法的五个核心步骤：</p><ol><li><p><strong>指数相加 (带偏置调整):</strong> 新指数 = (指数1 + 指数2) - Bias。理解为何需要减去一个 Bias。</p></li><li><p><strong>有效位相乘:</strong> 将两个操作数的有效位（Significand）相乘。</p></li><li><p><strong>结果规格化:</strong></p><ul><li>乘积的有效位结果范围是 [1, 4)，可能需要<strong>右移</strong>一位（如果结果 >= 2）并增加指数。</li><li>检查规格化后的指数是否上溢或下溢。</li></ul></li><li><p><strong>舍入 (Rounding):</strong> 将规格化后的结果舍入到目标精度。同样注意可能需要再次规格化。</p></li><li><p><strong>确定符号:</strong> 结果符号由两个操作数符号决定（同号为正，异号为负）。</p></li></ol></li><li><p><strong>模拟:</strong> 必须手动模拟一个简单的浮点乘法（如书中的 0.5 * (-0.4375)），精确跟踪算法的每一步。</p></li></ul></li><li><p><strong>Mind Map 构建建议:</strong></p><ul><li>在 &ldquo;3.5 浮点运算&rdquo; 下创建核心子分支 &ldquo;3.5.5 浮点乘法 [P1] ⭐⭐⭐ / 红色&rdquo;。</li><li>核心节点 &ldquo;⚙️ 核心算法 (图 3-16)&rdquo;: 详细列出 5 个步骤，重点解释指数处理（减 Bias）和规格化（主要是右移）。</li><li>子分支 &ldquo;📊 模拟 (0.5 * (-0.4375))&rdquo;: 详细记录每步计算结果。</li></ul></li></ul><p><strong>3.5.6 LEGv8 中的浮点指令 [P2 - Important]</strong></p><ul><li><p><strong>学习任务:</strong></p><ul><li><strong>寄存器:</strong> 了解 LEGv8 (及 ARMv8) 有独立的浮点寄存器：S0-S31 (单精度) 和 D0-D31 (双精度)，其中 Si 是 Di 的低 32 位。</li><li><strong>算术指令:</strong> 掌握主要的浮点算术指令：<code>FADDS/FADDD</code>​, <code>FSUBS/FSUBD</code>​, <code>FMULS/FMULD</code>​, <code>FDIVS/FDIVD</code>​。</li><li><strong>比较指令:</strong> 掌握浮点比较指令 <code>FCMPS/FCMPD</code>​，它们设置条件码，然后通过 <code>B.cond</code>​ 进行分支。</li><li><strong>数据传输:</strong> 掌握浮点加载/存储指令 <code>LDURS/STURS</code>​ (单精度) 和 <code>LDURD/STURD</code>​ (双精度)。注意地址计算仍使用通用寄存器 (Xn)。</li><li><strong>示例代码:</strong> 理解简单的浮点代码（如华氏度转摄氏度）如何映射到这些 LEGv8 指令。理解矩阵乘法示例中，双精度加载 (<code>LDURD</code>​)、乘法 (<code>FMULD</code>​)、加法 (<code>FADDD</code>​) 的使用，以及地址计算（基址+偏移量，涉及 LSL 和 ADD）。</li></ul></li><li><p><strong>Mind Map 构建建议:</strong></p><ul><li>在 &ldquo;3.5 浮点运算&rdquo; 下创建子分支 &ldquo;3.5.6 LEGv8 浮点指令 [P2] ⭐⭐ / 橙色&rdquo;。</li><li>子分支 &ldquo;浮点寄存器&rdquo;: S0-S31 (32b), D0-D31 (64b)。</li><li>子分支 &ldquo;算术指令&rdquo;: 列出 FADD, FSUB, FMUL, FDIV (S/D)。</li><li>子分支 &ldquo;比较指令&rdquo;: FCMP (S/D) -> B.cond。</li><li>子分支 &ldquo;数据传输&rdquo;: LDUR/STUR (S/D)。</li><li>子分支 &ldquo;示例分析&rdquo;: 链接到温度转换和矩阵乘法代码，标注关键指令。</li></ul></li></ul><p><strong>3.5.7 算术精确性 [P2 - Important]</strong></p><ul><li><p><strong>学习任务:</strong></p><ul><li><p><strong>核心问题:</strong> 理解浮点数是实数的近似，运算结果也需要近似，因此需要精确的舍入规则。</p></li><li><p><strong>舍入机制 (硬件支持):</strong></p><ul><li><strong>保护位 (Guard) & 舍入位 (Round):</strong> 理解为了精确舍入，硬件在计算中间结果时需要额外保留至少两位：保护位和舍入位。通过例子理解它们的作用。</li><li><strong>粘贴位 (Sticky):</strong> 理解粘贴位的作用：记录在右移过程中是否有“1”被移出舍入位之外，用于区分恰好等于 0.5 和大于 0.5 的情况，以实现更精确的“向偶数舍入”。</li></ul></li><li><p><strong>舍入模式:</strong> 了解 IEEE 754 定义的四种舍入模式（向上、向下、截断、向偶数舍入）。理解“向偶数舍入”（Round to nearest, ties to even）是最常用且默认的模式，其目标是统计上无偏。</p></li><li><p><strong>误差度量 (ULP):</strong> 了解 ULP (Unit in the Last Place) 的概念，作为衡量浮点误差的单位。理解 IEEE 754 保证基本运算误差在 0.5 ULP 之内。</p></li><li><p><strong>混合乘加 (Fused Multiply-Add, FMA):</strong> 理解 FMA 指令 <code>a = a + (b × c)</code>​ 的优势：只进行一次（最终加法后的）舍入，而不是两次（乘法后一次，加法后一次），从而提高精度和性能。</p></li></ul></li><li><p><strong>Mind Map 构建建议:</strong></p><ul><li><p>在 &ldquo;3.5 浮点运算&rdquo; 下创建子分支 &ldquo;3.5.7 算术精确性 [P2] ⭐⭐ / 橙色&rdquo;。</p></li><li><p>核心节点 &ldquo;💡 舍入机制&rdquo;:</p><ul><li>子分支 &ldquo;保护位 (G) & 舍入位 (R)&rdquo;: 记录作用（保存精度）。</li><li>子分支 &ldquo;粘贴位 (S)&rdquo;: 记录作用（区分 x.5 和 >x.5），用于向偶数舍入。</li></ul></li><li><p>子分支 &ldquo;💡 舍入模式&rdquo;: 列出四种，重点解释 &ldquo;向偶数舍入&rdquo;。</p></li><li><p>子分支 &ldquo;💡 误差度量 (ULP)&rdquo;: 记录概念，记录 IEEE 保证 (0.5 ULP)。</p></li><li><p>核心节点 &ldquo;💡 混合乘加 (FMA)&rdquo;: 记录操作 <code>a+(b*c)</code>​，优势（一次舍入，高精度，高性能）。</p></li></ul></li></ul><p><strong>3.5.8 小结 [P3 - Supplementary]</strong></p><ul><li><strong>学习任务:</strong> 快速回顾浮点是近似值，强调位模式本身无意义，由指令决定。了解非规格化数 (Denormals) 的概念（指数全 0，尾数非 0）和作用（渐进下溢，填补 0 和最小规格化数之间的空隙）。</li><li><strong>Mind Map 构建建议:</strong> 在 &ldquo;3.5 浮点运算&rdquo; 下创建子分支 &ldquo;3.5.8 小结 [P3] ⭐"。链接回顾核心概念。备注 &ldquo;Denormals: 渐进下溢&rdquo;。</li></ul><p><strong>3.6 并行与计算机算术：子字并行 [P2 - Important]</strong></p><ul><li><p><strong>学习任务:</strong></p><ul><li><strong>动机:</strong> 理解现代处理器利用宽数据通路（如 128 位或更宽）来并行处理多个较小数据单元（如 8 位、16 位、32 位）以加速图形、音频、视频等多媒体应用。</li><li><strong>核心概念 (SIMD):</strong> 理解子字并行 (Subword Parallelism) 的本质，即 SIMD (Single Instruction, Multiple Data) 的一种形式：一条指令同时对多个数据元素执行相同的操作。</li><li><strong>机制:</strong> 理解如何在宽加法器（如 128 位）内部通过分割进位链来实现并行处理（如 16 个 8 位加法）。</li><li><strong>ARMv8 SIMD (NEON 扩展):</strong> 了解 ARMv8 提供了专门的 SIMD 寄存器（V0-V31，128 位）和大量 SIMD 指令。了解指令如何通过后缀（如 <code>.16B</code>​, <code>.4S</code>​, <code>.2D</code>​）指定操作的数据宽度和数量。</li></ul></li><li><p><strong>Mind Map 构建建议:</strong></p><ul><li>创建主分支 &ldquo;3.6 子字并行 (SIMD) [P2] ⭐⭐ / 橙色&rdquo;。</li><li>记录 &ldquo;💡 动机&rdquo;: 加速媒体应用。</li><li>核心节点 &ldquo;💡 核心概念 (SIMD)&rdquo;: Single Instruction, Multiple Data。</li><li>子分支 &ldquo;⚙️ 机制&rdquo;: 宽数据通路 + 分割进位链。</li><li>子分支 &ldquo;ARMv8 SIMD (NEON)&rdquo;: 记录 V 寄存器 (128b)，记录指令后缀表示法 (如 ADD V1.16B, V2.16B, V3.16B)。</li></ul></li></ul><p><strong>3.7 实例： x86 中的流处理 SIMD 扩展和高级向量扩展 [P3 - Supplementary]</strong></p><ul><li><strong>学习任务:</strong> 了解 x86 也有类似的 SIMD 扩展（SSE, AVX）。了解 AVX 将寄存器宽度扩展到 256 位 (YMM)，允许同时操作更多数据（如 8 个单精度或 4 个双精度）。了解 AVX 引入了三地址指令格式。</li><li><strong>Mind Map 构建建议:</strong> 创建主分支 &ldquo;3.7 x86 SIMD (SSE/AVX) [P3] ⭐"。备注 &ldquo;x86 SIMD 扩展&rdquo;，记录 AVX (256b YMM), 三地址指令。</li></ul><p><strong>3.8 实例：其他的 ARMv8 算术指令 [P3 - Supplementary]</strong></p><ul><li><strong>学习任务:</strong> 浏览了解完整的 ARMv8 算术和 SIMD 指令集远比本章核心介绍的要丰富，包含更多变种和特殊功能指令。无需记忆细节。</li><li><strong>Mind Map 构建建议:</strong> 创建主分支 &ldquo;3.8 完整 ARMv8 算术/SIMD [P3] ⭐"。备注 &ldquo;指令集丰富性概览&rdquo;。</li></ul><p><strong>3.8.1 完整的 ARMv8 整数和浮点算术指令 [P3 - Supplementary]</strong><br><strong>3.8.2 完整的 ARMv8 SIMD 指令 [P3 - Supplementary]</strong></p><p><strong>3.9 加速：子字并行和矩阵乘法 [P2 - Important]</strong></p><ul><li><p><strong>学习任务:</strong></p><ul><li><strong>核心目的:</strong> 理解本节通过 DGEMM (双精度通用矩阵乘法) 实例，<strong>量化</strong>展示了使用子字并行/SIMD 指令（具体是 x86 AVX）相对于标量指令所能带来的显著性能提升。</li><li><strong>代码对比:</strong> 对比图 3-23 (标量) 和 图 3-25 (AVX) 的汇编代码（或图 3-22 和图 3-24 的 C 代码），识别出关键差异在于使用了并行加载 (<code>vmovapd %ymm...</code>​)、并行乘法 (<code>vmulpd</code>​)、并行加法 (<code>vaddpd</code>​) 以及广播指令 (<code>vbroadcastsd</code>​)。理解广播指令的作用（将一个标量值复制到向量寄存器的所有元素中）。</li><li><strong>性能结果:</strong> 记住优化后的 AVX 版本比未优化版本快了约 3.85 倍，接近理论的 4 倍加速（因为 AVX 对 4 个双精度数并行操作）。</li><li><strong>Turbo 模式影响:</strong> 了解 Intel Turbo Boost 技术可以通过临时提高时钟频率进一步提升性能，但其效果依赖于核心使用情况和散热。</li></ul></li><li><p><strong>Mind Map 构建建议:</strong></p><ul><li>创建主分支 &ldquo;3.9 加速实例: SIMD 与 DGEMM [P2] ⭐⭐ / 橙色&rdquo;。</li><li>核心节点 &ldquo;📊 性能对比&rdquo;: 记录 AVX 版本 vs. 标量版本性能提升倍数 (~3.85x)。</li><li>子分支 &ldquo;⚙️ AVX 实现关键&rdquo;: 并行加载/乘/加 (<code>pd</code>​ 后缀), 广播 (<code>vbroadcastsd</code>​)。</li><li>子分支 &ldquo;💡 Turbo Boost 影响&rdquo;: 临时提频，依赖散热。</li></ul></li></ul><p><strong>3.10 谬误与陷阱 [P3 - Supplementary]</strong></p><ul><li><p><strong>学习任务:</strong> 吸取经验教训：</p><ul><li>算术右移不完全等同于有符号除法（负数结果可能差 1）。</li><li>浮点加法不满足结合律，计算顺序影响结果。</li><li>并行浮点计算结果可能与串行不同，需要注意数值稳定性。</li><li>浮点精度问题可能导致严重后果（Pentium FDIV bug）。</li></ul></li><li><p><strong>Mind Map 构建建议:</strong> 创建主分支 &ldquo;3.10 谬误与陷阱 [P3] ⭐"。简要记录上述关键点。</p></li></ul><p><strong>3.11 本章小结 [P3 - Supplementary]</strong></p><ul><li><strong>学习任务:</strong> 利用小结回顾本章核心内容：整数（补码、乘除算法）、浮点（IEEE 754 表示、加乘算法、精度）、并行（SIMD）。再次强调计算机算术的有限性和近似性。</li><li><strong>Mind Map 构建建议:</strong> 创建主分支 &ldquo;3.11 小结 [P3] ⭐"。链接回顾本章核心 P1 节点。</li></ul><p><strong>3.12 历史观点与拓展阅读 [P3 - Supplementary]</strong></p><ul><li><strong>学习任务:</strong> 了解浮点标准化的历史、IEEE 754 的制定过程以及 x86 浮点栈结构的背景。</li><li><strong>Mind Map 构建建议:</strong> 创建主分支 &ldquo;3.12 历史 [P3] ⭐"。备注 &ldquo;浮点标准化历史 (在线)"。</li></ul><p><strong>3.13 练习题 [P3 - Supplementary]</strong></p><ul><li><strong>学习任务:</strong> 选择与 P1、P2 知识点直接相关的练习进行巩固。</li><li><strong>Mind Map 构建建议:</strong> 创建主分支 &ldquo;3.13 练习题 [P3] ⭐"。</li></ul><hr><p><strong>阶段三：总结与关联 (Synthesize & Connect)</strong></p><ul><li><p><strong>目标:</strong> 将本章学习的算术运算知识与前后章节联系起来，形成整体认识。</p></li><li><p><strong>行动:</strong></p><ol><li><strong>回顾思维导图:</strong> 检查导图结构是否清晰反映了知识的主次关系（P1 内容应最突出、连接最丰富）。</li><li><strong>内部关联:</strong> 思考本章内不同算术运算之间的联系（如减法基于加法，乘除硬件的相似性）。</li><li><strong>外部关联:</strong> 思考本章算术指令（如 ADD, SUB, MUL, SDIV, FADD, FMUL, LDUR, STUR 等）如何在第 2 章描述的指令格式中表示？算术运算的结果（如溢出、条件码）如何影响第 2 章学到的分支指令？浮点运算和 SIMD 如何影响第 1 章讨论的性能？</li><li><strong>完善导图:</strong> 在导图中使用箭头、注释等方式显式标出这些重要的内部和外部关联。</li></ol></li></ul><p><strong>阶段四：主动回忆与复述 (Active Recall & Elaboration)</strong></p><ul><li><p><strong>目标:</strong> 通过不看书和笔记，主动回忆和复述关键概念、算法和原理，检验掌握程度。</p></li><li><p><strong>行动:</strong></p><ol><li>尝试向他人（或自己）清晰地解释二进制补码加减法及溢出检测。</li><li>不看图，尝试徒手画出顺序乘法或除法的硬件框图和算法流程图。</li><li>解释 IEEE 754 标准的核心设计思想（隐含位、偏置指数、特殊值）。</li><li>复述浮点加法和乘法的关键步骤。</li><li>解释子字并行 (SIMD) 的基本原理和目的。</li></ol></li></ul></section><div class=post-navigation><a class=prev-post href=/post/2025-04-09-zlwhf2.html>&#171; 2025-04-09</a>
<a class=next-post href=/post/2025-04-10-z18pcdp.html>2025-04-10 &#187;</a></div></article></main></div><script type=text/javascript>document.addEventListener("DOMContentLoaded",function(){const t=document.querySelector(".search-toggle a"),e=document.getElementById("search-container"),n=document.getElementById("search-close"),s=document.getElementById("search-input");t.addEventListener("click",function(t){t.preventDefault(),e.classList.add("active"),s.focus()}),n.addEventListener("click",function(){e.classList.remove("active")}),document.addEventListener("keydown",function(t){t.key==="Escape"&&e.classList.remove("active")})})</script></body></html>