---
title: 第三章阅读
slug: di-san-zhang-yue-du-z26z9qi
url: /post/di-san-zhang-yue-du-z26z9qi.html
date: '2025-04-09 16:10:41+08:00'
lastmod: '2025-04-10 15:21:23+08:00'
toc: true
isCJKLanguage: true
---





**AI评估的章节目录与学习优先级:**

* 3.1 引言  **[P3 - Supplementary]**
* 3.2 加法和减法  **[P1 - Core]**
* 3.3 乘法  **[P1 - Core]**

  * 3.3.1 顺序乘法算法及硬件  **[P1 - Core]**
  * 3.3.2 有符号乘法  **[P2 - Important]**
  * 3.3.3 更快速的乘法  **[P2 - Important]**
  * 3.3.4 LEGv8 中的乘法  **[P2 - Important]**
  * 3.3.5 小结  **[P3 - Supplementary]**
* 3.4 除法  **[P1 - Core]**

  * 3.4.1 除法算法及硬件  **[P1 - Core]**
  * 3.4.2 有符号除法  **[P2 - Important]**
  * 3.4.3 更快速的除法  **[P2 - Important]**
  * 3.4.4 LEGv8 中的除法  **[P2 - Important]**
  * 3.4.5 小结  **[P3 - Supplementary]**
* 3.5 浮点运算  **[P1 - Core]**

  * 3.5.1 浮点表示  **[P1 - Core]**
  * 3.5.2 异常和中断  **[P2 - Important]**
  * 3.5.3 IEEE 754 浮点标准  **[P1 - Core]**
  * 3.5.4 浮点加法  **[P1 - Core]**
  * 3.5.5 浮点乘法  **[P1 - Core]**
  * 3.5.6 LEGv8 中的浮点指令  **[P2 - Important]**
  * 3.5.7 算术精确性  **[P2 - Important]**
  * 3.5.8 小结  **[P3 - Supplementary]**
* 3.6 并行与计算机算术：子字并行  **[P2 - Important]**
* 3.7 实例： x86 中的流处理 SIMD 扩展和高级向量扩展  **[P3 - Supplementary]**
* 3.8 实例：其他的 ARMv8 算术指令  **[P3 - Supplementary]**

  * 3.8.1 完整的 ARMv8 整数和浮点算术指令  **[P3 - Supplementary]**
  * 3.8.2 完整的 ARMv8 SIMD 指令  **[P3 - Supplementary]**
* 3.9 加速：子字并行和矩阵乘法  **[P2 - Important]**
* 3.10 谬误与陷阱  **[P3 - Supplementary]**
* 3.11 本章小结  **[P3 - Supplementary]**
* 3.12 历史观点与拓展阅读  **[P3 - Supplementary]**
* 3.13 练习题  **[P3 - Supplementary]**

---

**技术核心学习与思维导图构建指南 (任务列表)**

**思维导图根节点:**  Ch3: 计算机算术运算 ⭐⭐⭐

**3.1 引言 [P3 - Supplementary]**

* **学习任务:**  识别本章核心议题（计算机如何执行算术运算，包括整数和浮点数）及解决的关键问题（如实数表示、大数处理、乘除法硬件实现）。
* **Mind Map 构建建议:**  在根节点下创建分支 "3.1 引言 [P3] ⭐"，备注 "核心议题：整数/浮点运算实现"。

**3.2 加法和减法 [P1 - Core]**

* **学习任务:**

  * **机制:**  精确描述二进制按位加法的过程，特别是进位 (Carry) 的产生和逐位传递逻辑。
  * **机制:**  详解二进制减法如何通过加法（具体是加上减数的二进制补码）来实现。推导并理解 `A - B = A + (-B)`​ 在补码体系下的运算过程。
  * **核心概念:**  定义溢出 (Overflow)。
  * **核心原理:**  彻底理解有符号数加减法发生溢出的**充要条件** (参考图 3-2)。务必解释清楚：

    * 为何两个正数相加结果为负时发生溢出？（涉及向符号位的进位）
    * 为何两个负数相加结果为正时发生溢出？（涉及向符号位的进位）
    * 为何一个正数减去一个负数结果为负时发生溢出？（等价于正+正=负）
    * 为何一个负数减去一个正数结果为正时发生溢出？（等价于负+负=正）
    * 为何符号不同的数相加 或 符号相同的数相减 **永不** 发生溢出？
  * **机制:**  硬件如何检测这些溢出条件？（通常检查操作数符号和结果符号，或检查符号位的进位/借位）。
  * **概念:**  无符号数加减溢出条件是什么？（结果超出了表示范围）。为何地址计算中的无符号溢出通常可以被忽略？
  * **机制:**  饱和运算 (Saturating Operation) 的精确定义是什么？它如何处理溢出情况（钳位到最大/最小值）？对比与二进制补码的环绕 (wrap-around) 行为。思考其在媒体处理（如音量控制）中的适用性。
  *  **(P2 关联)**  超前进位加法器 (Carry Lookahead Adder) 的基本思想是什么？（并行计算进位以加速）它与简单逐位进位加法器的主要性能权衡是什么？（速度 vs 硬件复杂度，关联附录A.6）。
* **Mind Map 构建建议:**

  * 创建主分支 "3.2 加法与减法 [P1] ⭐⭐⭐ / 红色"。
  * 子分支 "⚙️ 二进制加法": 记录按位规则、进位传递。
  * 子分支 "⚙️ 二进制减法": 核心节点，记录通过 "加补码" 实现，展示 `A + (~B + 1)`​。
  * 核心节点 "⚠️ 溢出 (Overflow)":

    * 子分支 "💡 定义"。
    * 子分支 "有符号溢出条件": 详细列出图 3-2 的四种情况及其原因（符号变化、符号位进/借位）。用 🔗 连接到补码运算。
    * 子分支 "硬件检测机制"。
    * 子分支 "无符号溢出条件": 记录范围，解释地址计算忽略原因。
  * 子分支 "⚙️ 饱和运算": 记录定义（钳位）、对比补码环绕、应用场景 (媒体)。
  * (可选 P2 关联) 子分支 "💡 超前进位加法器": 记录基本思想（并行进位）、性能权衡（速度 vs 复杂度）。

**3.3 乘法 [P1 - Core]**

* **学习任务:**

  * **基础:**  理解 n 位乘以 m 位结果需要 n+m 位才能保证不丢失信息。在定长（如 64 位）运算中，这意味着什么？（可能发生溢出，或需要特殊指令处理高位结果）。
  * **术语:**  区分被乘数 (Multiplicand)、乘数 (Multiplier)、积 (Product)。
* **Mind Map 构建建议:**  创建主分支 "3.3 乘法 [P1] ⭐⭐⭐ / 红色"。记录术语，记录位数关系 `n*m -> n+m`​ 位。

**3.3.1 顺序乘法算法及硬件 [P1 - Core]**

* **学习任务:**

  * **核心算法 (图 3-4):**  彻底分解“纸笔”乘法算法的三个核心步骤：

    1. 检查乘数最低位：决定是否将被乘数加到当前的部分积上。
    2. 左移被乘数：为下一次可能的加法做准备（相当于乘以 2）。
    3. 右移乘数：处理下一位乘数。

    * 理解这三步如何模拟手动乘法的逐位乘、移位和累加过程。
  * **硬件演进 (图 3-3 vs 图 3-5):**

    * **结构 V1 (图 3-3):**  分析其组件（128 位被乘数寄存器、128 位 ALU、128 位积寄存器、64 位乘数寄存器）。理解为何需要 128 位宽度（被乘数需要左移 64 次）。分析其数据流。
    * **结构 V2 (图 3-5):**  分析其改进：被乘数寄存器和 ALU 减半 (64 位)，积寄存器右移而不是被乘数左移，乘数寄存器合并到积寄存器的右半部分。理解这些改进为何能减少硬件资源且功能等价。思考其潜在的性能优势（如减少数据通路延迟）。
  * **模拟:**  必须手动模拟一个简单的乘法（如书中的 4 位 0010 x 0011），精确跟踪图 3-4 算法下各个寄存器（被乘数、乘数、积）在**每一步**之后的值。
* **Mind Map 构建建议:**

  * 在 "3.3 乘法" 下创建子分支 "3.3.1 顺序算法与硬件 [P1] ⭐⭐⭐ / 红色"。
  * 核心节点 "⚙️ 核心算法 (图 3-4)": 列出 3 个步骤并解释目的。
  * 子分支 "⚙️ 硬件 V1 (图 3-3)": 记录组件、位宽（强调 128 位原因）、数据流。
  * 子分支 "⚙️ 硬件 V2 (图 3-5)": 记录改进点（64 位 ALU/被乘数、积右移、乘数合并）、优势（资源、性能）。
  * 子分支 "📊 4位模拟 (0010x0011)": 详细记录每步寄存器值变化。

**3.3.2 有符号乘法 [P2 - Important]**

* **学习任务:**

  * **方法1 (转换+符号):**  理解最简单的处理方式：先将操作数转为正数，执行无符号乘法，最后根据原始符号决定结果符号（同号为正，异号为负）。
  * **方法2 (直接算法):**  了解更高级的算法（如 Booth 算法，虽然书中未详述）可以直接处理补码。理解当使用类似顺序算法处理有符号数时，移位需要是**算术右移**（符号扩展）而不是逻辑右移。
* **Mind Map 构建建议:**

  * 在 "3.3 乘法" 下创建子分支 "3.3.2 有符号乘法 [P2] ⭐⭐ / 橙色"。
  * 记录 "方法1: 转换+定符号"。
  * 记录 "方法2: 直接算法要点": 需要算术移位。

**3.3.3 更快速的乘法 [P2 - Important]**

* **学习任务:**

  * **核心思想 (并行加法):**  理解加速乘法的关键在于并行处理多个部分积的相加，而不是顺序累加。
  * **机制 (多加法器):**  理解图 3-7 的基本结构：为乘数的每一位（或多位）设置加法器，并行计算部分积，然后通过树状结构（或阵列）快速将它们相加。对比与顺序算法的延迟差异（log2(n) vs n）。
  * **技术 (进位保留加法器):**  了解进位保留加法器 (Carry Save Adder, CSA) 可以进一步加速并行加法过程（将进位传播延迟到最后一步）。
* **Mind Map 构建建议:**

  * 在 "3.3 乘法" 下创建子分支 "3.3.3 快速乘法 [P2] ⭐⭐ / 橙色"。
  * 核心节点 "💡 核心思想": 并行加法。
  * 子分支 "⚙️ 机制 (图 3-7)": 多加法器阵列/树，延迟对比 (log2(n) vs n)。
  * 子分支 "💡 进位保留加法器 (CSA)": 记录作用（延迟进位传播）。

**3.3.4 LEGv8 中的乘法 [P2 - Important]**

* **学习任务:**

  * **指令:**  掌握 LEGv8 提供的核心乘法指令：

    * ​`MUL Rd, Rn, Rm`​: 计算 64 位乘积（结果的低 64 位）。
    * ​`SMULH Rd, Rn, Rm`​: 计算有符号乘积的高 64 位。
    * ​`UMULH Rd, Rn, Rm`​: 计算无符号乘积的高 64 位。
  * **应用:**  理解程序员需要根据操作数类型（有符号/无符号）和所需结果（完整 128 位或低 64 位）选择合适的指令。
  * **溢出检测:**  理解这些指令本身不设置溢出标志，需要软件通过检查高 64 位 (`SMULH`​/`UMULH`​ 的结果) 来判断 64 位乘法是否溢出。精确描述如何根据高 64 位判断有符号/无符号溢出。
* **Mind Map 构建建议:**

  * 在 "3.3 乘法" 下创建子分支 "3.3.4 LEGv8 乘法指令 [P2] ⭐⭐ / 橙色"。
  * 记录指令 `MUL`​, `SMULH`​, `UMULH`​ 及其功能。
  * 记录 "⚠️ 溢出检测": 软件负责，描述如何通过检查高 64 位进行判断。

**3.3.5 小结 [P3 - Supplementary]**

* **学习任务:**  快速回顾乘法核心思想（移位和加）及优化方向（并行）。
* **Mind Map 构建建议:**  在 "3.3 乘法" 下创建子分支 "3.3.5 小结 [P3] ⭐"，链接回顾核心算法和优化思想节点。

**3.4 除法 [P1 - Core]**

* **学习任务:**

  * **基础:**  理解除法是乘法的逆运算，但更复杂，且存在特殊情况（除零）。
  * **术语:**  区分被除数 (Dividend)、除数 (Divisor)、商 (Quotient)、余数 (Remainder)。掌握核心关系式：`被除数 = 商 × 除数 + 余数`​，以及 `0 <= |余数| < |除数|`​，且余数符号通常与被除数一致。
* **Mind Map 构建建议:**  创建主分支 "3.4 除法 [P1] ⭐⭐⭐ / 红色"。记录术语和核心关系式。

**3.4.1 除法算法及硬件 [P1 - Core]**

* **学习任务:**

  * **核心算法 (恢复余数法, 图 3-9):**  彻底分解基本的二进制除法算法步骤：

    1. **尝试减:**  余数寄存器减去除数寄存器。
    2. **判断与置商:**

        * 如果结果非负 (余数 >= 0)，说明够减，商对应位置 1。
        * 如果结果为负 (余数 < 0)，说明不够减，商对应位置 0，并且 **必须恢复余数** (将除数加回去)。
    3. **移位:**  除数寄存器右移（或余数/商寄存器左移，取决于硬件实现），为处理下一位做准备。
  * **硬件结构 (图 3-8, 图 3-11):**

    * **结构 V1 (图 3-8):**  分析其组件（128 位除数寄存器、128 位 ALU、128 位余数寄存器、64 位商寄存器）。理解除数为何需要 128 位并右移。
    * **结构 V2 (图 3-11):**  分析其改进（64 位 ALU/除数、余数寄存器左移、商寄存器合并到余数右半部分）。理解与乘法硬件的相似性。
  * **模拟:**  必须手动模拟一个简单的除法（如书中的 7 / 2，即 0111 / 0010），精确跟踪图 3-9 算法下各个寄存器（余数、除数、商）在**每一步**之后的值，特别注意余数恢复步骤。理解为何需要 n+1 (或 65) 次迭代。
* **Mind Map 构建建议:**

  * 在 "3.4 除法" 下创建子分支 "3.4.1 顺序算法与硬件 [P1] ⭐⭐⭐ / 红色"。
  * 核心节点 "⚙️ 核心算法 (恢复余数法, 图 3-9)": 列出 3 个步骤，强调第 2 步的判断、置商和 **恢复** 操作。
  * 子分支 "⚙️ 硬件 V1 (图 3-8)": 记录组件、位宽、数据流。
  * 子分支 "⚙️ 硬件 V2 (图 3-11)": 记录改进点、与乘法硬件相似性。
  * 子分支 "📊 4位模拟 (0111/0010)": 详细记录每步寄存器值变化，突出恢复步骤。

**3.4.2 有符号除法 [P2 - Important]**

* **学习任务:**

  * **商的符号:**  理解处理方法：先按绝对值进行除法，然后根据原始操作数符号决定商的符号（同号为正，异号为负）。
  * **余数的符号 (关键):**  掌握余数符号的约定：与被除数符号保持一致。理解这个约定的原因是为了保证 `被除数 = 商 × 除数 + 余数`​ 关系的一致性，并避免商的绝对值随符号变化。通过 +/-7 除以 +/-2 的例子来验证该约定。
* **Mind Map 构建建议:**

  * 在 "3.4 除法" 下创建子分支 "3.4.2 有符号除法 [P2] ⭐⭐ / 橙色"。
  * 记录 "商符号规则"。
  * 核心节点 "⚠️ 余数符号规则": 记录约定（同被除数），解释原因（保持公式一致性）。

**3.4.3 更快速的除法 [P2 - Important]**

* **学习任务:**

  * **挑战:**  理解为何除法比乘法更难并行加速（每步需要知道前一步减法结果的符号）。
  * **技术 (SRT 除法):**  了解 SRT 除法的基本思想：通过查找表根据除数和当前余数的高位来**预测**多位商，允许后续步骤修正错误预测。了解这是现代处理器常用的技术。
  *  **(P3 关联)**  了解非恢复余数除法 (Non-restoring) 和不执行除法 (Non-performing) 作为替代算法的基本思路（避免显式恢复步骤）。
* **Mind Map 构建建议:**

  * 在 "3.4 除法" 下创建子分支 "3.4.3 快速除法 [P2] ⭐⭐ / 橙色"。
  * 记录 "加速挑战" (依赖性)。
  * 核心节点 "💡 SRT 除法": 记录基本思想（查表预测多位商、可修正）。
  * (可选 P3 关联) 备注其他算法：非恢复、不执行。

**3.4.4 LEGv8 中的除法 [P2 - Important]**

* **学习任务:**

  * **指令:**  掌握 LEGv8 提供的核心除法指令：

    * ​`SDIV Rd, Rn, Rm`​: 有符号除法 (结果为商)。
    * ​`UDIV Rd, Rn, Rm`​: 无符号除法 (结果为商)。
  * **余数获取:**  理解 LEGv8 (以及 ARMv8) 没有直接计算余数的指令，需要通过 `商 = 被除数 / 除数`​, `余数 = 被除数 - 商 * 除数`​ 的计算序列来获得。
  * **异常处理:**  理解除法指令本身不处理除零或溢出（商太大无法表示），需要软件在执行除法前检查除数是否为零，以及执行后（如果需要）检查溢出。
* **Mind Map 构建建议:**

  * 在 "3.4 除法" 下创建子分支 "3.4.4 LEGv8 除法指令 [P2] ⭐⭐ / 橙色"。
  * 记录指令 `SDIV`​, `UDIV`​ 及其功能（只得商）。
  * 记录 "余数获取方法": 通过公式计算。
  * 记录 "⚠️ 异常处理": 软件负责检查除零、溢出。

**3.4.5 小结 [P3 - Supplementary]**

* **学习任务:**  快速回顾除法硬件与乘法相似，加速方法与挑战。
* **Mind Map 构建建议:**  在 "3.4 除法" 下创建子分支 "3.4.5 小结 [P3] ⭐"，链接回顾核心算法、硬件相似性、加速挑战节点。

**3.5 浮点运算 [P1 - Core]**

* **学习任务:**

  * **动机:**  理解需要浮点数来表示实数（带小数的数）以及非常大或非常小的数。
  * **核心概念 (科学记数法):**  理解二进制科学记数法 `±1.fraction × 2^exponent`​ 的形式。
  * **核心概念 (规格化):**  理解规格化 (Normalized) 的含义（小数点左边只有一位非零数字，在二进制中即为 1），及其优点（简化交换、简化算法、提高精度）。
  * **术语:**  区分尾数 (Fraction/Mantissa) 和有效位 (Significand，包含隐含的 1 和尾数)。区分指数 (Exponent)。
* **Mind Map 构建建议:**  创建主分支 "3.5 浮点运算 [P1] ⭐⭐⭐ / 红色"。记录动机、二进制科学记数法、规格化定义与优点、术语。

**3.5.1 浮点表示 [P1 - Core]**

* **学习任务:**

  * **核心权衡 (精度 vs. 范围):**  理解在固定字长（如 32/64 位）下，分配给尾数的位数和分配给指数的位数之间存在根本性的权衡：更多尾数位提高精度，更多指数位扩大表示范围。关联“设计原则3: 好的设计需要好的权衡”。
  * **单精度 (Single Precision / float):**  掌握其 32 位格式：1 位符号 (S)，8 位指数 (E)，23 位尾数 (F)。
  * **双精度 (Double Precision / double):**  掌握其 64 位格式：1 位符号 (S)，11 位指数 (E)，52 位尾数 (F)。理解其主要优势在于更高的精度，其次是更大的范围。
  * **表示的值 (初步):**  理解基本形式 `(-1)^S × Significand × 2^Exponent`​。注意此时还未引入隐含位和偏置指数。
* **Mind Map 构建建议:**

  * 在 "3.5 浮点运算" 下创建子分支 "3.5.1 浮点表示 [P1] ⭐⭐⭐ / 红色"。
  * 核心节点 "⚖️ 权衡": 精度 (尾数位数) vs. 范围 (指数位数)。
  * 子分支 "💡 单精度 (32位)": 记录格式 S(1) E(8) F(23)。
  * 子分支 "💡 双精度 (64位)": 记录格式 S(1) E(11) F(52)，记录主要优势（精度）。

**3.5.2 异常和中断 [P2 - Important]**

* **学习任务:**

  * **浮点异常:**  理解浮点运算中可能出现的异常情况：

    * 上溢 (Overflow): 正指数太大，超出指数表示范围。
    * 下溢 (Underflow): 负指数的绝对值太大，超出指数表示范围。
  * **处理机制:**  理解发生异常时，处理器通常能产生异常 (Exception) 或中断 (Interrupt)，保存出错指令地址，并跳转到特定的处理程序。了解这是操作系统或运行时环境处理错误的基础。
* **Mind Map 构建建议:**

  * 在 "3.5 浮点运算" 下创建子分支 "3.5.2 浮点异常 [P2] ⭐⭐ / 橙色"。
  * 记录 "⚠️ 上溢 (Overflow)" 定义。
  * 记录 "⚠️ 下溢 (Underflow)" 定义。
  * 记录 "⚙️ 处理机制": 异常/中断，保存 PC，跳转处理程序。

**3.5.3 IEEE 754 浮点标准 [P1 - Core]**

* **学习任务:**

  * **核心特性1 (隐含前导 1):**  深刻理解规格化浮点数的有效位 (Significand) 等于 `1 + Fraction`​。这个 '1' 是隐含的，不存储在尾数字段中，从而有效增加了一位精度（单精度 23+1=24 位，双精度 52+1=53 位）。理解为何 0 没有隐含 1（因为 0 的指数和尾数全为 0）。
  * **核心特性2 (偏置指数):**

    * **动机:**  理解引入偏置 (Bias) 的主要目的是使得指数部分的比较可以直接使用无符号整数比较器（即指数大的浮点数其指数部分编码也更大），便于排序等操作。避免负指数的补码表示带来的比较复杂性。
    * **机制:**  掌握指数的实际值 = 存储的指数值 - 偏置值。
    * **偏置值:**  记住单精度偏置为 127，双精度偏置为 1023。
  * **最终表示公式:**  整合上述特性，掌握 IEEE 754 浮点数的精确表示公式：`(-1)^S × (1 + Fraction) × 2^(Exponent - Bias)`​ (适用于规格化数)。
  * **核心特性3 (特殊值):**  理解 IEEE 754 使用特定的指数和尾数模式来表示特殊值：

    *  **±0:**  指数全 0，尾数全 0。
    *  **±Infinity (无穷):**  指数全 1，尾数全 0。（用于表示除零结果或溢出）
    * **NaN (Not a Number):**  指数全 1，尾数非 0。（用于表示无效操作结果，如 0/0, ∞-∞）
    *  **(P3 关联)**  非规格化数 (Denormals): 指数全 0，尾数非 0。（用于表示接近 0 的极小数，提供渐进下溢）
  * **编码图 (图 3-13):**  能够根据 S, E, F 的值判断表示的是 0、规格化数、非规格化数、无穷还是 NaN。
  * **示例转换:**  必须能够手动将简单的十进制小数（如 -0.75）转换为 IEEE 754 单/双精度二进制表示，反之亦然。
* **Mind Map 构建建议:**

  * 在 "3.5 浮点运算" 下创建核心子分支 "3.5.3 IEEE 754 标准 [P1] ⭐⭐⭐ / 红色"。
  * 核心节点 "💡 隐含前导 1": 解释机制 `Significand = 1 + Fraction`​，记录增加的精度，说明 0 的特殊性。
  * 核心节点 "💡 偏置指数": 解释动机（简化比较），记录机制 `实际指数 = 存储值 - Bias`​，记录偏置值 (127/1023)。
  * 核心节点 "📐 最终表示公式": 记录 `(-1)^S * (1 + F) * 2^(E - Bias)`​。
  * 核心节点 "💡 特殊值编码 (图 3-13)":

    * 子分支 "±0" (E=0, F=0)。
    * 子分支 "±Infinity" (E=max, F=0)。
    * 子分支 "NaN" (E=max, F≠0)。
    * (可选 P3 关联) 子分支 "Denormals" (E=0, F≠0)。
  * 子分支 "📊 示例转换": 记录手动转换步骤 (如 -0.75)。

**3.5.4 浮点加法 [P1 - Core]**

* **学习任务:**

  * **核心算法 (图 3-14):**  彻底掌握浮点加法的四个核心步骤：

    1. **指数对齐:**  找出指数较大的数，将指数较小的数的有效位（Significand）**右移**，直到两数指数相同。理解移位会损失精度。
    2. **有效位相加:**  将对齐后的有效位相加。
    3. **结果规格化:**

        * 可能需要**右移**（如果和导致最高位进位，如 9.999 + 0.016 = 10.015 -> 1.0015）并增加指数。
        * 可能需要**左移**（如果相减导致前导零，如 1.000 - 0.111 = 0.001 -> 1.000）并减少指数。
        * 检查规格化后的指数是否上溢或下溢。
    4. **舍入 (Rounding):**  将规格化后的结果舍入到目标精度。注意舍入可能导致再次需要规格化（步骤 3）。
  * **符号处理:**  理解和的符号由有效位相加的结果自然确定。
  * **硬件结构 (图 3-15):**  理解浮点加法单元的基本组成部分：指数比较器、多路选择器、有效位移位器、有效位加法器、规格化逻辑、舍入逻辑。能够将算法步骤对应到硬件单元。
  * **模拟:**  必须手动模拟一个简单的浮点加法（如书中的 0.5 + (-0.4375)），精确跟踪算法的每一步，包括指数对齐、有效位相加、规格化和舍入。
* **Mind Map 构建建议:**

  * 在 "3.5 浮点运算" 下创建核心子分支 "3.5.4 浮点加法 [P1] ⭐⭐⭐ / 红色"。
  * 核心节点 "⚙️ 核心算法 (图 3-14)": 详细列出 4 个步骤，对规格化（左右移、溢出检查）和舍入（可能需再次规格化）进行重点解释。
  * 子分支 "符号确定": 由有效位相加结果决定。
  * 子分支 "⚙️ 硬件结构 (图 3-15)": 记录主要组件及其功能，与算法步骤对应。
  * 子分支 "📊 模拟 (0.5 + (-0.4375))": 详细记录每步计算结果。

**3.5.5 浮点乘法 [P1 - Core]**

* **学习任务:**

  * **核心算法 (图 3-16):**  掌握浮点乘法的五个核心步骤：

    1. **指数相加 (带偏置调整):**  新指数 = (指数1 + 指数2) - Bias。理解为何需要减去一个 Bias。
    2. **有效位相乘:**  将两个操作数的有效位（Significand）相乘。
    3. **结果规格化:**

        * 乘积的有效位结果范围是 [1, 4)，可能需要**右移**一位（如果结果 >= 2）并增加指数。
        * 检查规格化后的指数是否上溢或下溢。
    4. **舍入 (Rounding):**  将规格化后的结果舍入到目标精度。同样注意可能需要再次规格化。
    5. **确定符号:**  结果符号由两个操作数符号决定（同号为正，异号为负）。
  * **模拟:**  必须手动模拟一个简单的浮点乘法（如书中的 0.5 * (-0.4375)），精确跟踪算法的每一步。
* **Mind Map 构建建议:**

  * 在 "3.5 浮点运算" 下创建核心子分支 "3.5.5 浮点乘法 [P1] ⭐⭐⭐ / 红色"。
  * 核心节点 "⚙️ 核心算法 (图 3-16)": 详细列出 5 个步骤，重点解释指数处理（减 Bias）和规格化（主要是右移）。
  * 子分支 "📊 模拟 (0.5 * (-0.4375))": 详细记录每步计算结果。

**3.5.6 LEGv8 中的浮点指令 [P2 - Important]**

* **学习任务:**

  * **寄存器:**  了解 LEGv8 (及 ARMv8) 有独立的浮点寄存器：S0-S31 (单精度) 和 D0-D31 (双精度)，其中 Si 是 Di 的低 32 位。
  * **算术指令:**  掌握主要的浮点算术指令：`FADDS/FADDD`​, `FSUBS/FSUBD`​, `FMULS/FMULD`​, `FDIVS/FDIVD`​。
  * **比较指令:**  掌握浮点比较指令 `FCMPS/FCMPD`​，它们设置条件码，然后通过 `B.cond`​ 进行分支。
  * **数据传输:**  掌握浮点加载/存储指令 `LDURS/STURS`​ (单精度) 和 `LDURD/STURD`​ (双精度)。注意地址计算仍使用通用寄存器 (Xn)。
  * **示例代码:**  理解简单的浮点代码（如华氏度转摄氏度）如何映射到这些 LEGv8 指令。理解矩阵乘法示例中，双精度加载 (`LDURD`​)、乘法 (`FMULD`​)、加法 (`FADDD`​) 的使用，以及地址计算（基址+偏移量，涉及 LSL 和 ADD）。
* **Mind Map 构建建议:**

  * 在 "3.5 浮点运算" 下创建子分支 "3.5.6 LEGv8 浮点指令 [P2] ⭐⭐ / 橙色"。
  * 子分支 "浮点寄存器": S0-S31 (32b), D0-D31 (64b)。
  * 子分支 "算术指令": 列出 FADD, FSUB, FMUL, FDIV (S/D)。
  * 子分支 "比较指令": FCMP (S/D) -> B.cond。
  * 子分支 "数据传输": LDUR/STUR (S/D)。
  * 子分支 "示例分析": 链接到温度转换和矩阵乘法代码，标注关键指令。

**3.5.7 算术精确性 [P2 - Important]**

* **学习任务:**

  * **核心问题:**  理解浮点数是实数的近似，运算结果也需要近似，因此需要精确的舍入规则。
  * **舍入机制 (硬件支持):**

    * **保护位 (Guard) &amp; 舍入位 (Round):**  理解为了精确舍入，硬件在计算中间结果时需要额外保留至少两位：保护位和舍入位。通过例子理解它们的作用。
    * **粘贴位 (Sticky):**  理解粘贴位的作用：记录在右移过程中是否有“1”被移出舍入位之外，用于区分恰好等于 0.5 和大于 0.5 的情况，以实现更精确的“向偶数舍入”。
  * **舍入模式:**  了解 IEEE 754 定义的四种舍入模式（向上、向下、截断、向偶数舍入）。理解“向偶数舍入”（Round to nearest, ties to even）是最常用且默认的模式，其目标是统计上无偏。
  * **误差度量 (ULP):**  了解 ULP (Unit in the Last Place) 的概念，作为衡量浮点误差的单位。理解 IEEE 754 保证基本运算误差在 0.5 ULP 之内。
  * **混合乘加 (Fused Multiply-Add, FMA):**  理解 FMA 指令 `a = a + (b × c)`​ 的优势：只进行一次（最终加法后的）舍入，而不是两次（乘法后一次，加法后一次），从而提高精度和性能。
* **Mind Map 构建建议:**

  * 在 "3.5 浮点运算" 下创建子分支 "3.5.7 算术精确性 [P2] ⭐⭐ / 橙色"。
  * 核心节点 "💡 舍入机制":

    * 子分支 "保护位 (G) & 舍入位 (R)": 记录作用（保存精度）。
    * 子分支 "粘贴位 (S)": 记录作用（区分 x.5 和 >x.5），用于向偶数舍入。
  * 子分支 "💡 舍入模式": 列出四种，重点解释 "向偶数舍入"。
  * 子分支 "💡 误差度量 (ULP)": 记录概念，记录 IEEE 保证 (0.5 ULP)。
  * 核心节点 "💡 混合乘加 (FMA)": 记录操作 `a+(b*c)`​，优势（一次舍入，高精度，高性能）。

**3.5.8 小结 [P3 - Supplementary]**

* **学习任务:**  快速回顾浮点是近似值，强调位模式本身无意义，由指令决定。了解非规格化数 (Denormals) 的概念（指数全 0，尾数非 0）和作用（渐进下溢，填补 0 和最小规格化数之间的空隙）。
* **Mind Map 构建建议:**  在 "3.5 浮点运算" 下创建子分支 "3.5.8 小结 [P3] ⭐"。链接回顾核心概念。备注 "Denormals: 渐进下溢"。

**3.6 并行与计算机算术：子字并行 [P2 - Important]**

* **学习任务:**

  * **动机:**  理解现代处理器利用宽数据通路（如 128 位或更宽）来并行处理多个较小数据单元（如 8 位、16 位、32 位）以加速图形、音频、视频等多媒体应用。
  * **核心概念 (SIMD):**  理解子字并行 (Subword Parallelism) 的本质，即 SIMD (Single Instruction, Multiple Data) 的一种形式：一条指令同时对多个数据元素执行相同的操作。
  * **机制:**  理解如何在宽加法器（如 128 位）内部通过分割进位链来实现并行处理（如 16 个 8 位加法）。
  * **ARMv8 SIMD (NEON 扩展):**  了解 ARMv8 提供了专门的 SIMD 寄存器（V0-V31，128 位）和大量 SIMD 指令。了解指令如何通过后缀（如 `.16B`​, `.4S`​, `.2D`​）指定操作的数据宽度和数量。
* **Mind Map 构建建议:**

  * 创建主分支 "3.6 子字并行 (SIMD) [P2] ⭐⭐ / 橙色"。
  * 记录 "💡 动机": 加速媒体应用。
  * 核心节点 "💡 核心概念 (SIMD)": Single Instruction, Multiple Data。
  * 子分支 "⚙️ 机制": 宽数据通路 + 分割进位链。
  * 子分支 "ARMv8 SIMD (NEON)": 记录 V 寄存器 (128b)，记录指令后缀表示法 (如 ADD V1.16B, V2.16B, V3.16B)。

**3.7 实例： x86 中的流处理 SIMD 扩展和高级向量扩展 [P3 - Supplementary]**

* **学习任务:**  了解 x86 也有类似的 SIMD 扩展（SSE, AVX）。了解 AVX 将寄存器宽度扩展到 256 位 (YMM)，允许同时操作更多数据（如 8 个单精度或 4 个双精度）。了解 AVX 引入了三地址指令格式。
* **Mind Map 构建建议:**  创建主分支 "3.7 x86 SIMD (SSE/AVX) [P3] ⭐"。备注 "x86 SIMD 扩展"，记录 AVX (256b YMM), 三地址指令。

**3.8 实例：其他的 ARMv8 算术指令 [P3 - Supplementary]**

* **学习任务:**  浏览了解完整的 ARMv8 算术和 SIMD 指令集远比本章核心介绍的要丰富，包含更多变种和特殊功能指令。无需记忆细节。
* **Mind Map 构建建议:**  创建主分支 "3.8 完整 ARMv8 算术/SIMD [P3] ⭐"。备注 "指令集丰富性概览"。

**3.8.1 完整的 ARMv8 整数和浮点算术指令 [P3 - Supplementary]**   
**3.8.2 完整的 ARMv8 SIMD 指令 [P3 - Supplementary]**

**3.9 加速：子字并行和矩阵乘法 [P2 - Important]**

* **学习任务:**

  * **核心目的:**  理解本节通过 DGEMM (双精度通用矩阵乘法) 实例，**量化**展示了使用子字并行/SIMD 指令（具体是 x86 AVX）相对于标量指令所能带来的显著性能提升。
  * **代码对比:**  对比图 3-23 (标量) 和 图 3-25 (AVX) 的汇编代码（或图 3-22 和图 3-24 的 C 代码），识别出关键差异在于使用了并行加载 (`vmovapd %ymm...`​)、并行乘法 (`vmulpd`​)、并行加法 (`vaddpd`​) 以及广播指令 (`vbroadcastsd`​)。理解广播指令的作用（将一个标量值复制到向量寄存器的所有元素中）。
  * **性能结果:**  记住优化后的 AVX 版本比未优化版本快了约 3.85 倍，接近理论的 4 倍加速（因为 AVX 对 4 个双精度数并行操作）。
  * **Turbo 模式影响:**  了解 Intel Turbo Boost 技术可以通过临时提高时钟频率进一步提升性能，但其效果依赖于核心使用情况和散热。
* **Mind Map 构建建议:**

  * 创建主分支 "3.9 加速实例: SIMD 与 DGEMM [P2] ⭐⭐ / 橙色"。
  * 核心节点 "📊 性能对比": 记录 AVX 版本 vs. 标量版本性能提升倍数 (~3.85x)。
  * 子分支 "⚙️ AVX 实现关键": 并行加载/乘/加 (`pd`​ 后缀), 广播 (`vbroadcastsd`​)。
  * 子分支 "💡 Turbo Boost 影响": 临时提频，依赖散热。

**3.10 谬误与陷阱 [P3 - Supplementary]**

* **学习任务:**  吸取经验教训：

  * 算术右移不完全等同于有符号除法（负数结果可能差 1）。
  * 浮点加法不满足结合律，计算顺序影响结果。
  * 并行浮点计算结果可能与串行不同，需要注意数值稳定性。
  * 浮点精度问题可能导致严重后果（Pentium FDIV bug）。
* **Mind Map 构建建议:**  创建主分支 "3.10 谬误与陷阱 [P3] ⭐"。简要记录上述关键点。

**3.11 本章小结 [P3 - Supplementary]**

* **学习任务:**  利用小结回顾本章核心内容：整数（补码、乘除算法）、浮点（IEEE 754 表示、加乘算法、精度）、并行（SIMD）。再次强调计算机算术的有限性和近似性。
* **Mind Map 构建建议:**  创建主分支 "3.11 小结 [P3] ⭐"。链接回顾本章核心 P1 节点。

**3.12 历史观点与拓展阅读 [P3 - Supplementary]**

* **学习任务:**  了解浮点标准化的历史、IEEE 754 的制定过程以及 x86 浮点栈结构的背景。
* **Mind Map 构建建议:**  创建主分支 "3.12 历史 [P3] ⭐"。备注 "浮点标准化历史 (在线)"。

**3.13 练习题 [P3 - Supplementary]**

* **学习任务:**  选择与 P1、P2 知识点直接相关的练习进行巩固。
* **Mind Map 构建建议:**  创建主分支 "3.13 练习题 [P3] ⭐"。

---

**阶段三：总结与关联 (Synthesize &amp; Connect)**

* **目标:**  将本章学习的算术运算知识与前后章节联系起来，形成整体认识。
* **行动:**

  1. **回顾思维导图:**  检查导图结构是否清晰反映了知识的主次关系（P1 内容应最突出、连接最丰富）。
  2. **内部关联:**  思考本章内不同算术运算之间的联系（如减法基于加法，乘除硬件的相似性）。
  3. **外部关联:**  思考本章算术指令（如 ADD, SUB, MUL, SDIV, FADD, FMUL, LDUR, STUR 等）如何在第 2 章描述的指令格式中表示？算术运算的结果（如溢出、条件码）如何影响第 2 章学到的分支指令？浮点运算和 SIMD 如何影响第 1 章讨论的性能？
  4. **完善导图:**  在导图中使用箭头、注释等方式显式标出这些重要的内部和外部关联。

**阶段四：主动回忆与复述 (Active Recall &amp; Elaboration)**

* **目标:**  通过不看书和笔记，主动回忆和复述关键概念、算法和原理，检验掌握程度。
* **行动:**

  1. 尝试向他人（或自己）清晰地解释二进制补码加减法及溢出检测。
  2. 不看图，尝试徒手画出顺序乘法或除法的硬件框图和算法流程图。
  3. 解释 IEEE 754 标准的核心设计思想（隐含位、偏置指数、特殊值）。
  4. 复述浮点加法和乘法的关键步骤。
  5. 解释子字并行 (SIMD) 的基本原理和目的。
