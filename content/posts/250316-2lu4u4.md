---
title: '25-03-16 '
slug: 250316-2lu4u4
url: /post/250316-2lu4u4.html
date: '2025-03-16 13:02:08+08:00'
lastmod: '2025-03-16 19:41:43+08:00'
toc: true
isCJKLanguage: true
---



# 25-03-16

*This is a follow-up to my article “*​*[The 70% problem: Hard truths about AI-assisted coding](https://addyo.substack.com/p/the-70-problem-hard-truths-about)*​ *”这是我的文章“*  *[70% 的问题：关于人工智能辅助编码的残酷事实](https://addyo.substack.com/p/the-70-problem-hard-truths-about)*​ *”的后续*

AI coding assistants like Cursor, Cline, Copilot and WindSurf have transformed how software is built, shouldering much of the grunt work and boilerplate. Yet, as experienced developers and industry leaders note, there [remains](https://addyo.substack.com/p/the-70-problem-hard-truths-about) a crucial portion of software engineering that AI **does not** handle well – roughly that last “30%” of the job that separates a toy solution from a production-ready system. This gap includes the hard parts: understanding complex requirements, architecting maintainable systems, handling edge cases, and ensuring code correctness. In other words, while AI can generate *code*, it often struggles with *engineering*.  
Cursor、Cline、Copilot 和 WindSurf 等 AI 编码助手已经改变了软件的构建方式，承担了大部分繁重的工作和样板。然而，正如经验丰富的开发人员和行业领导者所指出的那样，软件工程中[仍有](https://addyo.substack.com/p/the-70-problem-hard-truths-about)一部分关键部分是 AI**无法**处理的——大约是将玩具解决方案与可用于生产的系统区分开来的最后“30%”的工作。这一差距包括困难的部分：理解复杂的需求、构建可维护的系统、处理极端情况以及确保代码的正确性。换句话说，虽然 AI 可以生成*代码*，但它在*工程方面*往往举步维艰。

Tim O’Reilly, reflecting on decades of technology shifts, [reminds us](https://www.oreilly.com/radar/the-end-of-programming-as-we-know-it/) that each leap in automation has changed *how* we program but not *why* we need skilled programmersWe’re not facing the **end of programming**, but rather “the end of programming as we know it today,” meaning developers’ roles are evolving, not evaporating.  
蒂姆·奥莱利 \(Tim O'Reilly\) 回顾了几十年的技术变迁，[提醒我们](https://www.oreilly.com/radar/the-end-of-programming-as-we-know-it/)，自动化的每一次飞跃都改变了我们的编程*方式*，但并没有改变我们需要熟练程序员的*原因*。我们面临的不是**编程的终结**，而是“我们今天所知的编程的终结”，这意味着开发人员的角色正在演变，而不是消失。

The challenge for today’s engineers is to embrace AI for what it does best \(the first 70%\) while doubling down on the durable skills and insights needed for the remaining 30%. This article dives into expert insights to identify which human skills remain crucial. We’ll explore what senior developers should continue to leverage and what junior developers must invest in to thrive alongside AI.  
当今工程师面临的挑战是，在充分利用人工智能最擅长的领域（前 70%）的同时，加倍培养剩余 30% 所需的持久技能和洞察力。本文深入探讨专家见解，以确定哪些人类技能仍然至关重要。我们将探讨高级开发人员应继续利用哪些技能，以及初级开发人员必须投资哪些技能才能与人工智能一起蓬勃发展。

The goal: **pragmatic guidance** for maximizing the value of that irreplaceable 30%, with actionable takeaways for engineers at every level.  
目标：**提供实用的指导**，最大限度地发挥那不可替代的 30% 的价值，并为各个级别的工程师提供可行的指导。

AI-based coding tools are astonishingly good at certain tasks. They excel at producing boilerplate, writing routine functions, and getting projects *most of the way* to completion. In fact, many developers find that an AI assistant can implement an initial solution that covers roughly 70% of the requirements.  
基于人工智能的编码工具在某些任务上表现出色。它们擅长生成样板、编写常规函数以及完成*大部分*项目。事实上，许多开发人员发现，人工智能助手可以实现涵盖大约 70% 需求的初始解决方案。

This is often the straightforward, patterned part of the work – the kind of code that follows well-trod paths or common frameworks. As one Hacker News commenter observed, AI is superb at handling the  **“accidental complexity”**  of software \(the repetitive, mechanical stuff\) while the  **“essential complexity”**  – understanding and managing the inherent complexity of a problem – remains on [human shoulders](https://news.ycombinator.com/item?id=42336553#:~:text=Even%20though%20Fred%20Brooks%20explained,help%20with%20the%20accidental%20tasks). In Fred Brooks’ classic terms, AI tackles the incidental, but not the intrinsic, difficulties of development.  
这通常是工作中简单而有模式的部分——遵循常规路径或通用框架的代码。正如一位 Hacker News 评论员所观察到的，人工智能在处理软件的 **“偶然复杂性”**  （重复、机械的东西）方面非常出色，而 **“本质复杂性”**  ——理解和管理问题固有的复杂性——仍然落在[人类的肩上](https://news.ycombinator.com/item?id=42336553#:~:text=Even%20though%20Fred%20Brooks%20explained,help%20with%20the%20accidental%20tasks)。用 Fred Brooks 的经典术语来说，人工智能解决了开发过程中的偶然困难，而不是内在困难。

Where do these tools struggle? Experienced engineers consistently report a “last mile” gap. AI can generate a plausible solution, but **the final 30%**  – covering edge cases, refining the architecture, and ensuring maintainability – “needs serious human expertise”.  
这些工具的难点在哪里？经验丰富的工程师一直报告“最后一英里”的差距。人工智能可以生成一个合理的解决方案，但**最后的 30%**  ——涵盖边缘情况、改进架构和确保可维护性——“需要大量的人类专业知识”。

For example, an AI might give you a function that technically works for the basic scenario, but it won’t automatically account for unusual inputs, race conditions, performance constraints, or future requirements unless explicitly told. AI can get you most of the way there, but that final crucial 30% \(edge cases, keeping things maintainable, and solid architecture\) needs serious human expertise.  
例如，人工智能可能会为您提供一个在技术上适用于基本场景的功能，但除非明确告知，否则它不会自动考虑异常输入、竞争条件、性能限制或未来需求。人工智能可以帮您实现大部分目标，但最后至关重要的 30%（边缘情况、保持可维护性和稳固的架构）需要人类的专业知识。

Moreover, AI has a known tendency to generate **convincing but incorrect** output. It may introduce subtle bugs or “hallucinate” nonexistent functions and libraries. Steve Yegge wryly likens today’s large language models \(LLMs\) to  *“wildly productive junior developers”*  – incredibly fast and enthusiastic, but  *“potentially whacked out on mind-altering drugs,”*  prone to concocting crazy or unworkable approaches.  
此外，众所周知，人工智能倾向于生成**令人信服但不正确的**输出。它可能会引入微妙的错误或“产生幻觉”不存在的函数和库。Steve Yegge 讽刺地将当今的大型语言模型 \(LLMs\) 比作 *“非常高效的初级开发人员”*  ——速度极快、热情高涨，但 *“可能因服用精神错乱的药物而精神错乱”，* 容易想出疯狂或不可行的方法。

In Yegge’s [words](https://itrevolution.com/articles/observing-the-impact-of-ai-on-law-firms-software-and-writing-winners-and-losers/#:~:text=When%20I%20was%20talking%20with,crazy%20and%20fundamentally%20unworkable%20approaches), an LLM can spew out code that looks polished at first glance, yet if a less experienced developer naively says “Looks good to me\!” and runs with it, **hilarity**  **(or disaster)**  **ensues** in the following weeks. The AI doesn’t truly *understand* the problem; it stitches together patterns that *usually* make sense. Only a human can discern whether a seemingly fine solution hides long-term landmines. Simon Willison [echoed this](https://simonwillison.net/2024/Jul/12/the-death-of-the-junior-developer/#:~:text=Also%20included%3A%20a%20story%20about,the%20problem%20space%20could%20catch) after seeing an AI propose a bewitchingly clever design that *only a senior engineer with deep understanding of the problem* could recognize as flawed. The lesson: AI’s confidence far exceeds its reliability.  
用 Yegge 的[话](https://itrevolution.com/articles/observing-the-impact-of-ai-on-law-firms-software-and-writing-winners-and-losers/#:~:text=When%20I%20was%20talking%20with,crazy%20and%20fundamentally%20unworkable%20approaches)来说，LLM 可以写出乍一看很完美的代码，但如果经验不足的开发人员天真地说“我觉得这很好！”并照搬了，那么接下来的几周**就会发生滑稽的事情（或灾难）**  。人工智能并没有真正*理解*问题；它只是将*通常*有意义的模式拼凑在一起。只有人类才能辨别看似不错的解决方案是否隐藏着长期的地雷。Simon Willison在看到人工智能提出了一个非常巧妙的设计后[也表达了同样的](https://simonwillison.net/2024/Jul/12/the-death-of-the-junior-developer/#:~:text=Also%20included%3A%20a%20story%20about,the%20problem%20space%20could%20catch)看法，*只有对问题有深入了解的高级工程师*才能识别出这个设计存在缺陷。教训是：人工智能的信心远远超过它的可靠性。

Crucially, current AIs [do not](https://news.ycombinator.com/item?id=42954885#:~:text=Currently%2C%20LLM%20AIs%20are%20stochastic,form%20that%20can%20be%20reused) create fundamentally new **abstractions or strategies** beyond their training data. They won’t invent a novel algorithm or an innovative architecture for you – they remix what’s known. They also won’t take responsibility for decisions. As one engineer noted,  *“AIs don’t have ‘better ideas’ than what their training data contains. They don’t take responsibility for their work.”*   
至关重要的是，当前的人工智能[不会](https://news.ycombinator.com/item?id=42954885#:~:text=Currently%2C%20LLM%20AIs%20are%20stochastic,form%20that%20can%20be%20reused)在其训练数据之外创造全新的**抽象或策略**。它们不会为您发明一种新颖的算法或创新的架构——它们只是重新组合已知的内容。它们也不会对决策负责。正如一位工程师所说，  *“人工智能没有比其训练数据所包含的‘更好的想法’。它们不对自己的工作负责。 ”*

All of this means that the creative and analytical thinking – deciding *what* to build, *how* to structure it, and *why* – firmly remains a human domain. In summary, AI is a **force multiplier** for developers, handling the repetitive 70% and giving us a “turbo boost” in productivity. But it is *not* a silver bullet that can replace human judgment. The remaining 30% of software engineering – the hard parts – still requires skills that only trained, thoughtful developers can bring. Those are the **durable skills** to focus on. As one [discussion](https://www.reddit.com/r/ChatGPTCoding/comments/1hx6cks/this_article_struck_me_as_largely_accurate_the_70/#:~:text=In%20short%3A%20AI%20is%20a,engineering%20practices%20are%20still%20essential) put it:  *“AI is a powerful tool, but it’s not a magic bullet... human judgment and good software engineering practices are still essential.”*   
所有这些都意味着，创造性和分析性思维——决定构建*什么*、*如何*构建以及*为什么*构建——仍然是人类的领域。总而言之，人工智能是开发人员的**力量倍增器**，处理重复的 70% 工作，并为我们带来生产力的“涡轮增压”。但它*并不是*可以取代人类判断的灵丹妙药。软件工程的其余 30%——最难的部分——仍然需要只有训练有素、深思熟虑的开发人员才能掌握的技能。这些是需要关注的**持久技能**。正如一次[讨论](https://www.reddit.com/r/ChatGPTCoding/comments/1hx6cks/this_article_struck_me_as_largely_accurate_the_70/#:~:text=In%20short%3A%20AI%20is%20a,engineering%20practices%20are%20still%20essential)所说：  *“人工智能是一种强大的工具，但它不是灵丹妙药……人类的判断力和良好的软件工程实践仍然必不可少。 ”*

To thrive in an AI-enhanced development world, engineers should double down on the enduring skills and practices that AI cannot \(yet\) replicate. These capabilities will remain crucial no matter how advanced our tools become. In particular, focus on strengthening the following:  
为了在人工智能增强的开发世界中蓬勃发展，工程师应该加倍努力掌握人工智能无法复制的持久技能和实践。无论我们的工具变得多么先进，这些能力仍然至关重要。特别是要重点加强以下方面：

* **System design &amp; architectural thinking:**  Designing a coherent system requires understanding trade-offs, constraints, and the “big picture” beyond writing a few functions. AI can generate code but won’t automatically choose the best architecture for a complex problem. The **overall design** – how components interact, how data flows, how to ensure scalability and security – is part of that 30% that demands human insight. Senior developers have long honed this skill, and junior devs should actively cultivate it. Think in terms of patterns and principles \(e.g. separation of concerns, modularity\) – these guide an AI-generated solution toward maintainability. Remember, *solid architecture doesn’t emerge by accident*; it needs an experienced human hand on the wheel.  
  **系统设计和架构思维：** 设计一个连贯的系统需要理解权衡、约束和“全局”，而不仅仅是编写几个函数。人工智能可以生成代码，但不会自动为复杂问题选择最佳架构。**整体设计**——组件如何交互、数据如何流动、如何确保可扩展性和安全性——是需要人类洞察力的 30% 的一部分。高级开发人员长期以来一直在磨练这项技能，初级开发人员应该积极培养它。从模式和原则的角度思考（例如关注点分离、模块化）——这些会引导人工智能生成的解决方案走向可维护性。请记住，*坚实的架构不会偶然出现*；它需要经验丰富的人手来掌控。
* **Handling edge cases &amp; ambiguity:**  Real-world software lives rife with oddball scenarios and changing requirements. AI tends to solve the *general* case by default. It’s up to the developer to ask “What if…?” and probe for weaknesses. Durable skill here is **critical thinking and foresight** – enumerating edge cases, anticipating failures, and addressing them in code or design. This might mean thinking of null input, network outages, unusual user actions, or integration with other systems. **Domain knowledge** plays a role too: understanding the business context or the user’s environment will reveal edge cases that a generic AI simply doesn’t know about. Experienced engineers habitually consider these scenarios; juniors should practice systematically testing boundaries and questioning assumptions.  
  **处理极端情况和歧义：** 现实世界中的软件充斥着奇怪的场景和不断变化的需求。人工智能倾向于默认解决*一般*情况。开发人员需要问“如果……会怎样？”并探究弱点。这里持久的技能是**批判性思维和远见**——列举极端情况，预测故障，并在代码或设计中解决它们。这可能意味着考虑空输入、网络中断、不寻常的用户操作或与其他系统的集成。**领域知识**也发挥着作用：了解业务背景或用户环境将揭示通用人工智能根本不知道的极端情况。经验丰富的工程师习惯性地考虑这些场景；初级工程师应该系统地练习测试边界和质疑假设。
* **Code review &amp; quality assurance:**  With AI writing lots of code, the ability to rigorously review and test that code becomes even more critical.  *“Everyone will need to get a lot more serious about testing and reviewing code,”*  Steve Yegge emphasizes. Treat AI-generated code as you would a human junior developer’s output – you are the code reviewer responsible for catching bugs, security flaws, or sloppy implementations. This means strong skills in **unit testing, integration testing, and debugging**. Writing good tests is a durable skill that forces you to understand the spec and verify correctness. It’s wise to assume nothing works until proven otherwise. As one developer [noted](https://www.reddit.com/r/ChatGPTCoding/comments/1h6qyl0/why_ai_is_making_software_dev_skills_more/#:~:text=AI%20made%20me%20a%20better,functional%20but%20horribly%20optimized%20code), AI often yields  *“functional but horribly optimized code”*  until you guide it through iterative improvement. Cultivate a testing mindset: verify every critical logic path, use static analysis or linters, and don’t shy away from rewriting AI-given code if it doesn’t meet your quality bar. **Quality assurance** is not an area to outsource to AI – it’s where human diligence shines.  
  **代码审查和质量保证：** 由于人工智能编写了大量代码，严格审查和测试代码的能力变得更加重要。  *“每个人都需要更加认真地对待测试和审查代码，”*  Steve Yegge 强调道。将人工智能生成的代码视为人类初级开发人员的输出——您是负责发现错误、安全漏洞或草率实现的代码审查者。这意味着您需要具备强大的**单元测试、集成测试和调试**技能。编写良好的测试是一项持久的技能，它迫使您了解规范并验证正确性。在证明其他方法无效之前，最好假设它们都行不通。正如一位开发人员[所说](https://www.reddit.com/r/ChatGPTCoding/comments/1h6qyl0/why_ai_is_making_software_dev_skills_more/#:~:text=AI%20made%20me%20a%20better,functional%20but%20horribly%20optimized%20code)，人工智能通常会产生 *“功能齐全但优化糟糕的代码”，* 除非您指导它进行迭代改进。培养测试思维：验证每一条关键的逻辑路径，使用静态分析或 linters，如果人工智能给出的代码不符合您的质量标准，请不要回避重写它。**质量保证**不是可以外包给人工智能的领域——这是人类勤奋的闪光点。
* **Debugging &amp; problem-solving skills:**  When software doesn’t work as expected, you need real problem-solving chops to diagnose and fix it. AI can assist with debugging \(for example, by suggesting possible causes\), but it lacks true understanding of the specific context in which your application runs. Being able to reason through a complex bug – reproducing it, isolating the cause, understanding the underlying systems \(OS, databases, libraries\) – is a timeless engineering skill. This often requires a strong grasp of fundamentals \(how memory and state work, concurrency, etc.\) that junior developers must learn through practice. Use AI as a helper \(it might explain error messages or suggest fixes\), but *don’t rely on it blindly*. The skill to **methodically troubleshoot** and apply first principles when debugging sets great developers apart. It’s also a feedback loop: debugging AI-written code will teach you to prompt the AI better next time or avoid certain patterns.  
  **调试和解决问题的能力：** 当软件不能按预期工作时，你需要真正的解决问题的能力来诊断和修复它。人工智能可以协助调试（例如，通过建议可能的原因），但它缺乏对应用程序运行的特定环境的真正理解。能够推理复杂的错误——重现它、隔离原因、理解底层系统（操作系统、数据库、库）——是一项永恒的工程技能。这通常需要牢牢掌握基础知识（内存和状态如何工作、并发性等），初级开发人员必须通过实践来学习。使用人工智能作为助手（它可能会解释错误消息或建议修复），但*不要盲目依赖它*。在调试时**有条不紊地排除故障**和应用第一原则的技能让优秀的开发人员脱颖而出。这也是一个反馈循环：调试人工智能编写的代码将教你下次更好地提示人工智能或避免某些模式。
* **Maintaining context &amp; Big-Picture understanding:**  Software projects are not just isolated coding tasks; they exist within a larger context of user needs, timelines, legacy code, and team processes. AI has no innate sense of your project’s history or the rationale behind certain decisions \(unless you explicitly feed all that into the prompt, which is often impractical\). Humans need to carry that context. A durable skill here is **systems thinking** – understanding how a change in one part of the system might impact another, how the software serves the business objectives, and how all the moving pieces connect. This holistic perspective lets you use AI outputs appropriately. For example, if an AI suggests a clever shortcut that contradicts a regulatory requirement or company convention, you’ll catch it because you know the context. Junior engineers should make a point to learn the background of their projects and read design docs, so they can develop judgment about what fits and what doesn’t.  
  **保持背景和全局理解：** 软件项目不仅仅是孤立的编码任务；它们存在于更大的用户需求、时间线、遗留代码和团队流程的背景中。人工智能无法天生了解您的项目历史或某些决策背后的理由（除非您将所有这些明确地输入到提示中，但这通常是不切实际的）。人类需要掌握这种背景。这里一个持久的技能是**系统思维**——了解系统一个部分的变化如何影响另一个部分，软件如何服务于业务目标，以及所有移动部件如何连接。这种整体视角让您可以适当地使用人工智能输出。例如，如果人工智能建议一个巧妙的捷径，与监管要求或公司惯例相矛盾，你会抓住它，因为你知道背景。初级工程师应该注意了解他们项目的背景并阅读设计文档，这样他们就可以判断什么合适，什么不合适。
* **Communication &amp; collaboration:**  Building software is a team sport. AI doesn’t attend meetings \(thank goodness\) – humans still must talk to other humans to clarify requirements, discuss trade-offs, and coordinate work. Strong communication skills are as valuable as ever. Senior developers should leverage their ability to explain complex ideas, mentor others, and articulate vision. Junior developers should practice asking good questions and describing problems clearly \(both to colleagues and to AI\). Interestingly, prompting an AI is itself a form of communication; it requires you to precisely express what you want. This overlaps with a core engineering skill: **requirements analysis**. If you can formulate a clear prompt or spec, it means you’ve thought through the problem. Additionally, sharing knowledge, writing documentation, and reviewing others’ code are collaborative skills that AI cannot replace. In the future, as developers work “with” AI, the human-to-human collaboration in a team – making sure the right problems are being solved – stays vital. One emerging trend is that developers may focus more on **high-level design discussions** \(often with AI as a participant\) and on coordinating tasks, essentially taking on more of a conductor role. Communication and leadership skills will serve you well in that conductor’s seat.  
  **沟通与协作：** 开发软件是一项团队运动。人工智能不会参加会议（谢天谢地）——人类仍然必须与其他人交谈以澄清需求、讨论权衡和协调工作。强大的沟通技巧比以往任何时候都更有价值。高级开发人员应该利用他们解释复杂想法、指导他人和表达愿景的能力。初级开发人员应该练习提出好问题并清楚地描述问题（对同事和人工智能）。有趣的是，提示人工智能本身就是一种沟通形式；它要求你准确地表达你想要什么。这与一项核心工程技能重叠：**需求分析**。如果你能制定明确的提示或规范，这意味着你已经仔细考虑过这个问题。此外，分享知识、编写文档和审查他人的代码是人工智能无法取代的协作技能。在未来，当开发人员“与”人工智能一起工作时，团队中的人与人之间的协作——确保解决正确的问题——仍然至关重要。一个新兴趋势是，开发人员可能会更多地关注**高层设计讨论**（通常以 AI 作为参与者）和协调任务，本质上更多地承担指挥角色。沟通和领导能力将使您在指挥席上大有裨益。
* **Adaptability &amp; continuous learning:**  Finally, a meta-skill: the ability to learn new tools and adapt to change. The field of AI-assisted development is evolving rapidly. Senior engineers who keep an open mind and learn how to effectively use new AI features will remain ahead of the curve – Tim O’Reilly suggests that developers who are  *“eager to learn new skills”*  will see the biggest productivity boosts from AI. Junior developers, in turn, should invest in learning the *fundamentals* deeply **and** staying curious about new techniques. This combination enables you to harness AI as a tool without becoming dependent on it. It’s a balancing act: use AI to accelerate your growth, but also occasionally practice without it to ensure you’re not skipping core learning \(some developers do an “[AI detox](https://www.reddit.com/r/ChatGPTCoding/comments/1hzr495/what_are_you_doing_to_prevent_skill_atrophy/#:~:text=What%20are%20you%20doing%20to,keep%20your%20basic%20skills)” periodically to keep their raw coding skills sharp. In short, be the engineer who learns constantly – that’s a career-proof skill in any era.  
  **适应性和持续学习：** 最后，还有一项元技能：学习新工具和适应变化的能力。人工智能辅助开发领域正在迅速发展。保持开放心态并学习如何有效使用新人工智能功能的高级工程师将保持领先地位——Tim O'Reilly 认为，  *“渴望学习新技能”* 的开发人员将从人工智能中获得最大的生产力提升。初级开发人员则应该投入精力深入学习*基础知识*​ **，并对**新技术保持好奇心。这种结合使你能够利用人工智能作为一种工具，而不会依赖它。这是一种平衡行为：使用人工智能来加速你的成长，但偶尔也要练习不使用人工智能，以确保你没有跳过核心学习（一些开发人员会定期进行“[人工智能排毒](https://www.reddit.com/r/ChatGPTCoding/comments/1hzr495/what_are_you_doing_to_prevent_skill_atrophy/#:~:text=What%20are%20you%20doing%20to,keep%20your%20basic%20skills)”，以保持他们原始的编码技能敏锐）。简而言之，做一个不断学习的工程师——这是在任何时代都适合职业发展的技能。

These skills form the human advantage in software engineering. They are **durable** because they don’t expire with the next framework or tooling change; if anything, AI’s rise makes them more pronounced. Simon Willison has argued that AI assistance actually makes strong programming *skills more valuable, not less*, because those with expertise can leverage the tools to far greater effect.  
这些技能构成了软件工程中的人类优势。它们之所以**经久不衰**，是因为它们不会随着下一个框架或工具的改变而过期；如果说有什么不同的话，那就是人工智能的崛起使它们更加突出。西蒙·威利森 \(Simon Willison\) 认为，人工智能的帮助实际上使强大的编程*技能更有价值，而不是更少*，因为那些拥有专业知识的人可以充分利用这些工具，发挥更大的作用。

A powerful machine in unskilled hands can be dangerous or wasted, but in capable hands it’s transformative. In the AI era, an experienced engineer is like a seasoned pilot with a new advanced co-pilot: the journey can go faster and farther, but the pilot must still navigate the storms and ensure a safe landing.  
一台强大的机器落入不熟练的人手中可能会很危险或浪费，但落入熟练的人手中却可以带来变革。在人工智能时代，经验丰富的工程师就像经验丰富的飞行员和新的高级副驾驶：旅程可以更快更远，但飞行员仍必须驾驭风暴，确保安全着陆。

For senior engineers, the advent of AI coding tools should be seen as an opportunity to amplify your impact – if you leverage your experience in the right ways. Senior developers typically possess deep domain knowledge, intuition for what could go wrong, and the ability to make high-level technical decisions.  
对于高级工程师来说，AI 编码工具的出现应该被视为扩大影响力的机会——前提是你能以正确的方式利用自己的经验。高级开发人员通常拥有深厚的领域知识、对可能出现的问题的直觉以及做出高级技术决策的能力。

These strengths are part of the 30% that AI can’t handle alone. Here’s how seasoned developers can maximize their value:  
这些优势是 AI 无法独自处理的 30% 的一部分。以下是经验丰富的开发人员如何最大限度地发挥其价值的方法：

* **Be the architect and the Editor-in-Chief:**  Let AI handle the first draft of code, while you focus on architecting the solution and then **refining** the AI’s output. In many organizations, we may see a shift where teams need “only senior associates” who “\(a\) describe the tasks to be done \(i.e. create the prompts\), and \(b\) review the resulting work for accuracy and correctness”. Embrace that model. As a senior dev, you can translate complex requirements into effective prompts or specifications for an AI assistant, then use your critical eye to vet every line produced. You are effectively pair-programming with the AI – it’s the fast typer, but you’re the brain. Maintain high standards during review: ensure the code meets your organization’s quality, security, and performance benchmarks. By acting as architect and editor, you prevent the “high review burden” from overwhelming you. \(A cautionary note: if junior staff simply throw raw AI output over the wall to you, push back – instill a process where they must verify AI-generated work first, so you’re not the sole safety net.  
  **成为架构师和主编：** 让 AI 处理代码的初稿，而您则专注于设计解决方案，然后**优化**AI 的输出。在许多组织中，我们可能会看到一种转变，即团队只需要“高级助理”，他们“（a）描述要完成的任务（即创建提示），（b）审查最终工作的准确性和正确性”。接受这种模式。作为高级开发人员，您可以将复杂的需求转化为有效的提示或 AI 助手规范，然后用您的批判眼光审查生成的每一行代码。您实际上是在与 AI 结对编程——它是快速打字者，但您是大脑。在审查期间保持高标准：确保代码符合组织的质量、安全性和性能基准。通过充当架构师和编辑，您可以避免“高审查负担”压垮您。 （注意事项：如果初级员工只是将原始的人工智能输出扔给你，请反击——灌输一个必须首先验证人工智能生成的工作的流程，这样你就不是唯一的安全网。）
* **Use AI as a force multiplier for big initiatives:**  Senior engineers often drive large projects or tackle hairy refactors that juniors can’t approach alone. AI can supercharge these efforts by handling a lot of mechanical changes or exploring alternatives under your guidance. Steve Yegge introduced the term **Chat-Oriented Programming**  **(**​**[CHOP](https://sourcegraph.com/blog/the-death-of-the-junior-developer)**​ **)**  for this style of working – “coding via iterative prompt refinement” with the AI as a collaborator. Leverage CHOP to be more ambitious in what you take on. As Simon Willison noted, having AI assistance “lowers the bar for when a project is worth investing time in at all” since what might have taken days could be done in hours. Senior devs can thus attempt those “wouldn’t it be nice if…?” projects that always seemed slightly out of reach. The key is to remain the guiding mind: you decide which tools or approaches to pursue, and you integrate the pieces into a cohesive whole. Your experience allows you to sift the AI’s suggestions – accepting those that fit, rejecting those that don’t.  
  **使用 AI 作为大计划的力量倍增器：** 高级工程师经常推动大型项目或解决初级工程师无法独自完成的棘手重构。AI 可以通过在您的指导下处理大量机械变化或探索替代方案来增强这些努力。Steve Yegge 为这种工作方式引入了**聊天导向编程**  **(**   **[CHOP](https://sourcegraph.com/blog/the-death-of-the-junior-developer)**   **)** 一词——“通过迭代快速改进进行编码”，AI 作为合作者。利用 CHOP 让您在承担的工作中更具雄心。正如 Simon Willison 所说，拥有 AI 的帮助“降低了项目值得投入时间的门槛”，因为原本可能需要几天才能完成的工作可以在几个小时内完成。因此，高级开发人员可以尝试那些“如果……会不会很好？”的项目，这些项目似乎总是有点遥不可及。关键是要保持指导思想：您决定采用哪些工具或方法，并将各个部分整合成一个有凝聚力的整体。您的经验让您可以筛选 AI 的建议——接受合适的建议，拒绝不合适的建议。
* **Mentor and set standards in the AI Era:**  Another crucial role for senior engineers is to **coach** less experienced team members on effective use of AI and on the timeless best practices. You likely have hard-won knowledge of pitfalls that juniors may not see \(memory leaks, off-by-one errors, concurrency hazards, etc.\). With juniors now potentially generating code via AI, it’s important to teach them how to self-review and test that code. Set an example by demonstrating thorough testing of AI contributions, and encourage a culture of not blindly trusting machine output. Some organizations \(and even law firms\) have instituted rules that if someone uses an AI, they must *disclose it and verify the results themselves* – not just assume a senior will catch mistakes. Seniors should champion such norms on their teams: AI is welcome, but diligence is required. By mentoring juniors in this way, you offload some of the oversight burden and help them grow into that 30% skillset more quickly.  
  **在人工智能时代指导和制定标准：** 高级工程师的另一个关键角色是**指导**经验不足的团队成员有效使用人工智能和永恒的最佳实践。您可能已经掌握了初级工程师可能看不到的陷阱（内存泄漏、差一错误、并发风险等）的来之不易的知识。由于初级工程师现在可能通过人工智能生成代码，因此教会他们如何自我审查和测试代码非常重要。通过展示对人工智能贡献的全面测试来树立榜样，并鼓励一种不盲目信任机器输出的文化。一些组织（甚至律师事务所）已经制定了规则，如果有人使用人工智能，他们必须*披露并亲自验证结果*——而不仅仅是假设高级工程师会发现错误。高级工程师应该在他们的团队中倡导这样的规范：欢迎人工智能，但需要勤奋。通过以这种方式指导初级工程师，您可以减轻一些监督负担，并帮助他们更快地掌握那 30% 的技能。
* **Continue to cultivate domain mastery and foresight:**  Your broad experience and context are more important than ever. Senior developers often have historical knowledge of why things are built a certain way or how an industry operates. This **domain mastery** lets you catch AI’s missteps that a newcomer wouldn’t. Continue investing in understanding the problem domain deeply – that might mean staying up to date with the business’s needs, user feedback, or new regulations that affect the software. AI won’t automatically incorporate these considerations unless told. When you combine domain insight with AI’s speed, you get the best outcomes. Also, use your foresight to steer AI. For instance, if you know that a quick fix will create maintenance pain down the line, you can instruct the AI to implement a more sustainable solution. Seniors should trust their instincts honed over years – if a code snippet “looks off” or too good to be true, dig in. Nine times out of ten there’s something your intuition spotted that the AI didn’t account for. Being able to foresee the second- and third-order effects of code is a hallmark of senior engineers; don’t let the convenience of AI blunt that habit. Instead, apply it to whatever the AI produces.  
  **继续培养领域精通和远见：** 你的广泛经验和背景比以往任何时候都重要。高级开发人员通常具有历史知识，了解事物以某种方式构建的原因或行业如何运作。这种**领域精通**让你能够发现新手无法发现的人工智能的失误。继续投资深入了解问题领域——这可能意味着要随时了解业务需求、用户反馈或影响软件的新法规。除非得到告知，否则人工智能不会自动纳入这些考虑因素。当你将领域洞察力与人工智能的速度结合起来时，你会得到最好的结果。此外，利用你的远见来引导人工智能。例如，如果你知道快速修复会在后期造成维护麻烦，你可以指示人工智能实施更可持续的解决方案。资深开发人员应该相信他们多年磨练出来的直觉——如果一个代码片段“看起来不对劲”或好得令人难以置信，那就深入研究。十有八九，你的直觉会发现人工智能没有考虑到的东西。能够预见代码的二阶和三阶效应是高级工程师的标志；不要让人工智能的便利削弱这一习惯。相反，将其应用于人工智能产生的任何东西。
* **Leverage soft skills and leadership:**  With AI shouldering some coding, senior developers can spend more energy on the human side of engineering. This includes communicating with stakeholders, leading design meetings, and making judgment calls that align technology with business strategy. Tim O’Reilly and others suggest that as rote coding becomes easier, the value shifts to deciding *what* to build and *how to orchestrate* complex systems. Senior engineers are often the ones orchestrating and seeing the big picture. Step up to that role. Volunteer to write that architecture roadmap, to evaluate which tools \(AI or otherwise\) to adopt, or to define coding guidelines for AI usage in your org. These are tasks AI can’t do – they require experience, human discretion and often cross-team consensus-building. By amplifying your leadership presence, you ensure that you’re not just a code generator \(replaceable by another tool\), but an indispensable **technical leader** guiding the team in this new era.  
  **利用软技能和领导力：**  AI 承担了一些编码工作，高级开发人员可以将更多精力投入到工程的人性化方面。这包括与利益相关者沟通、主持设计会议以及做出将技术与业务战略相结合的判断。Tim O'Reilly 和其他人认为，随着死记硬背的编码变得越来越容易，价值将转移到决定构建*什么*以及*如何协调*复杂系统。高级工程师通常是协调和看清大局的人。承担起这个角色。自愿编写架构路线图，评估采用哪些工具（AI 或其他），或定义组织中 AI 使用的编码指南。这些是 AI 无法完成的任务——它们需要经验、人类的判断力，并且通常需要跨团队达成共识。通过扩大你的领导力，你可以确保你不仅仅是一个代码生成器（可以被其他工具替代），而是一个在这个新时代指导团队不可或缺的**技术领导者**。

In short, **continue doing what seasoned developers do best**: see the forest for the trees.  
简而言之，**继续做经验丰富的开发人员最擅长的事情**：只见树木，不见森林。

AI will help you chop a lot more trees, but someone still needs to decide *which* trees to cut and *how* to build a stable house from the lumber. Your judgment, strategic thinking, and mentorship are now even more critical. A senior developer who harnesses AI effectively can be dramatically more productive than one who doesn’t – but the ones who truly excel will be those who **apply their human strengths to amplify the AI’s output**, not just let the AI run wild.  
人工智能将帮助你砍伐更多的树木，但仍然需要有人决定砍伐*哪些*树木以及*如何*用木材建造坚固的房屋。你的判断力、战略思维和指导现在变得更加重要。有效利用人工智能的高级开发人员的生产力可能比没有利用人工智能的高级开发人员高得多——但真正出类拔萃的人将是那些**利用人类优势来扩大人工智能产出的人**，而不是让人工智能肆意妄为。

As one Redditor quipped,  *“AI is a programming force multiplier”*  that  *“greatly increases the productivity of senior programmers”* . The multiplier effect is real, but it’s your expertise that’s being multiplied. Keep that expertise sharp and at the center of the development process.  
正如一位 Reddit 用户所说，  *“人工智能是一种编程力量倍增器”*  ，它 *“极大地提高了高级程序员的生产力”*  。倍增效应是真实存在的，但倍增的是你的专业知识。保持专业知识的敏锐性，并将其置于开发过程的中心。

If you’re a junior or less-experienced developer, you might feel a mix of excitement and anxiety about AI. On one hand, AI assistants can write code that you might not know how to write yourself, potentially accelerating your learning. On the other hand, there are headlines like “death of the junior developer” suggesting entry-level coding jobs are at risk.  
如果你是初级或经验不足的开发人员，你可能会对人工智能感到兴奋和焦虑。一方面，人工智能助手可以编写你自己可能不知道如何编写的代码，这可能会加速你的学习。另一方面，有“初级开发人员的死亡”之类的标题暗示入门级编码工作面临风险。

The truth is somewhere in between: AI is changing the early-career experience, but junior developers *are not obsolete*. You do, however, need to be proactive in developing skills that ensure you’re contributing value beyond what an AI can churn out. Here’s how to invest in yourself to handle that 30% gap effectively:  
事实介于两者之间：人工智能正在改变早期的职业体验，但初级开发人员*并没有过时*。然而，你确实需要积极主动地发展技能，以确保你贡献的价值超出人工智能所能创造的价值。以下是如何投资自己以有效弥补这 30% 的差距：

* **Learn the fundamentals – don’t skip the “why”:**  It’s tempting to lean on AI for answers to every question \(“How do I do X in Python?”\) and never truly absorb the underlying concepts. Resist that urge. Use AI as a tutor, not just an answer vending machine. For example, when AI gives you a piece of code, ask *why* it chose that approach, or have it explain the code line by line. Make sure you understand concepts like data structures, algorithms, memory management, and concurrency without always deferring to AI. The reason is simple: when the AI’s output is wrong or incomplete, you need your own mental model to recognize and fix it. As one engineer [noted](http://6cks/this_article_struck_me_as_largely_accurate_the_70/#:~:text=,you%20might%20actually%20learn%20less), if you’re “not actively engaging with why the AI is generating certain code, you might actually learn less”, hindering your growth. So take time to read documentation, write small programs from scratch, and solidify your core knowledge. These fundamentals are durable; they’ll serve you even as the tools around you change.  
  **学习基础知识——不要跳过“为什么”：** 人们很容易依赖人工智能来回答每个问题（“我如何用 Python 做 X？”），而从不真正吸收底层概念。抵制这种冲动。将人工智能用作导师，而不仅仅是答案自动售货机。例如，当人工智能给你一段代码时，问问它*为什么*选择这种方法，或者让它逐行解释代码。确保你理解数据结构、算法、内存管理和并发等概念，而不要总是听从人工智能。原因很简单：当人工智能的输出错误或不完整时，你需要自己的心理模型来识别和修复它。正如一位工程师[所说](http://6cks/this_article_struck_me_as_largely_accurate_the_70/#:~:text=,you%20might%20actually%20learn%20less)，如果你“不积极参与人工智能生成某些代码的原因，你实际上可能会学到更少”，从而阻碍你的成长。因此，花点时间阅读文档，从头开始编写小程序，巩固你的核心知识。这些基础知识是持久的；即使你周围的工具发生变化，它们也会为你服务。
* **Practice problem solving &amp; debugging without the AI safety net:**  To build real confidence, sometimes you have to fly solo. Many developers advocate doing an “AI-free day” or otherwise limiting AI assistance periodically. This ensures you can still solve problems with just your own skills, which is important for avoiding skill atrophy. You’ll find it forces you to truly think through a problem’s logic, which in turn makes you better at using AI \(since you can direct it more intelligently\). Additionally, whenever you encounter a bug or error in AI-generated code, jump in and debug it *yourself* before asking the AI to fix it. You’ll learn much more by stepping through a debugger or adding print statements to see what’s going wrong. Consider AI suggestions as hints, not final answers. Over time, tackling those last tricky bits of a task will build your skill in the very areas AI struggles – exactly what makes you valuable.  
  **在没有人工智能安全网的情况下练习解决问题和调试：** 要建立真正的信心，有时你必须独自行动。许多开发人员主张进行“无人工智能日”或定期限制人工智能的协助。这可以确保你仍然可以仅凭自己的技能解决问题，这对于避免技能萎缩非常重要。你会发现它迫使你真正思考问题的逻辑，这反过来会让你更好地使用人工智能（因为你可以更智能地指导它）。此外，每当你遇到人工智能生成的代码中的错误或错误时，在要求人工智能修复它之前，请先*自己*调试它。通过逐步执行调试器或添加打印语句来查看出了什么问题，你将学到更多。将人工智能的建议视为提示，而不是最终答案。随着时间的推移，解决任务的最后棘手部分将培养你在人工智能困难领域的技能——这正是你的价值所在。
* **Focus on testing and verification:**  As a junior dev, one of the best habits you can develop is writing tests for your code. This is doubly true if you use AI to generate code. When you get a chunk of code from an LLM, don’t assume it’s correct – challenge it. Write unit tests \(or use manual tests\) to see if it truly handles the requirements and edge cases. This accomplishes two things: \(1\) it catches issues in the AI’s output, and \(2\) it trains you to think about expected behavior before trusting an implementation. You might even use the AI to help write tests, but *you* define what to test. Steve Yegge’s advice about taking testing and code review seriously applies at all levels. If you cultivate a reputation for carefully verifying your work \(AI-assisted or not\), senior colleagues will trust you more and you’ll avoid the scenario where they feel you’re just “dumping” questionable code on them. In practical terms, start treating testing as an integral part of development, not an afterthought. Learn how to use testing frameworks, how to do exploratory manual testing, and how to systematically reproduce bugs. These skills not only make you better at the 30% work, they also accelerate your understanding of how the code really works. Remember: if you catch a bug that the AI introduced, **you** just did something the AI couldn’t – that’s added value.  
  **专注于测试和验证：** 作为初级开发人员，您可以养成的最佳习惯之一就是为您的代码编写测试。如果您使用 AI 生成代码，则更是如此。当您从 LLM 获得一段代码时，不要假设它是正确的 - 挑战它。编写单元测试（或使用手动测试）以查看它是否真正处理了需求和边缘情况。这可以实现两件事：（1）它捕获 AI 输出中的问题，（2）它训练您在信任实现之前考虑预期的行为。您甚至可以使用 AI 来帮助编写测试，但*您*定义要测试的内容。Steve Yegge 关于认真对待测试和代码审查的建议适用于所有级别。如果您培养了仔细验证工作（无论是否由 AI 辅助）的声誉，高级同事会更加信任您，并且您将避免他们认为您只是在“倾倒”可疑代码的情况。实际上，开始将测试视为开发的一个组成部分，而不是事后的想法。学习如何使用测试框架、如何进行探索性手动测试以及如何系统地重现错误。这些技能不仅能让你更好地完成 30% 的工作，还能加速你对代码实际工作原理的理解。请记住：如果你发现了 AI 引入的错误，**你**就做了 AI 无法做到的事情——这就是附加值。
* **Build an eye for maintainability:**  Junior devs often focus on “getting it to work.” But in the AI era, getting a basic working version is easy – the AI can do that. The harder part \(and what you should focus on\) is making code that’s **readable, maintainable, and clean**. Start developing an eye for good code structure and style. Compare the AI’s output with best practices you know of; if the AI code is messy or overly complex, take the initiative to refactor it. For instance, if an LLM gives you a 50-line function that does too many things, you can split it into smaller functions. If variable names are unclear, rename them. Essentially, pretend you’re a human code reviewer \(even if you’re junior\) and improve the AI’s code as if a peer wrote it. This will help you internalize good design principles. Over time, you’ll start prompting the AI in ways that yield cleaner code to begin with \(because you’ll specify the style you want\). Maintainers of software \(often teams working months or years later\) will thank you, and you’ll prove that you’re thinking beyond just “make it run” – you’re thinking like an engineer. Keeping things maintainable is exactly in that human-driven 30%, so make it your concern from the start of your career.  
  **培养对可维护性的洞察力：** 初级开发人员通常专注于“让代码运行”。但在人工智能时代，获得一个基本的可运行版本很容易——人工智能可以做到这一点。更难的部分（也是你应该关注的）是编写**可读、可维护和干净的**代码。开始培养对良好代码结构和风格的洞察力。将人工智能的输出与你所知道的最佳实践进行比较；如果人工智能代码混乱或过于复杂，请主动重构它。例如，如果LLM给你一个 50 行的函数，它做了太多的事情，你可以将它拆分成更小的函数。如果变量名不清楚，请重命名它们。本质上，假装你是一个人类代码审查者（即使你是初级的），并改进人工智能的代码，就像同行编写的一样。这将帮助你内化好的设计原则。随着时间的推移，你将开始以产生更干净的代码的方式提示人工智能（因为你会指定你想要的风格）。软件维护人员（通常是数月或数年后工作的团队）会感谢你，而你将证明你的想法不仅仅是“让它运行”——你像工程师一样思考。保持事物可维护性正是人为驱动的 30%，所以从你的职业生涯一开始就把它作为你的关注点。
* **Develop your prompting and tooling skills**  **(wisely):**  There’s no denying that “prompt engineering” – the skill of interacting with AI tools effectively – is useful. As a junior dev, you should absolutely learn how to phrase questions to AI, how to give it proper context, and how to iterate on prompts to improve the output. These are new skills that can set you apart \(many experienced devs are still figuring this out too\!\). However, remember that prompting well is often a proxy for understanding the problem well. If you find you can’t get the AI to do what you want, it might be because *you* need to clarify your own understanding first. Use that as a signal. One strategy is to outline a solution in plain English yourself before asking the AI to implement it. Also, experiment with different AI tools \(Copilot, Claude, etc.\) to see their strengths and weaknesses. The more fluent you are with these assistants, the more productive you can be – but never treat their output as infallible. Think of AI like a super-charged Stack Overflow: an aid, not an authority. You might even build small personal projects using AI to push your limits \(e.g. “Can I build a simple web app with AI’s help?”\). Doing so will teach you how to integrate AI into a development workflow, which is a great skill to bring into a team. Just balance it with periods of working without the net, as mentioned earlier.  
  **明智地发展你的提示和工具技能：** 不可否认，“提示工程”——与人工智能工具有效交互的技能——是有用的。作为一名初级开发人员，你绝对应该学习如何向人工智能提出问题，如何给它适当的背景，以及如何迭代提示以改进输出。这些是可以让你脱颖而出的新技能（许多经验丰富的开发人员也仍在弄清楚这一点！）。但是，请记住，良好的提示通常是理解问题的一种方式。如果你发现你无法让人工智能做你想做的事情，那可能是因为*你*需要先澄清自己的理解。把它当作一个信号。一种策略是在要求人工智能实施之前，自己用简单的英语概述解决方案。此外，尝试不同的人工智能工具（Copilot、Claude 等）以了解它们的优缺点。你对这些助手的熟练程度越高，你的工作效率就越高——但永远不要把它们的输出视为万无一失。把人工智能想象成一个超级强大的 Stack Overflow：一种辅助工具，而不是权威。你甚至可以使用人工智能来构建小型个人项目，以突破自己的极限（例如，“我可以在人工智能的帮助下构建一个简单的 Web 应用程序吗？”）。这样做将教会你如何将人工智能集成到开发工作流程中，这是一项非常适合团队使用的技能。只需平衡好它与没有网络的工作时间，如前所述。
* **Seek feedback and mentorship:**  Lastly, one durable skill that will accelerate your growth is the ability to **seek out feedback** and learn from others. AI won’t get offended if you ignore its advice, but your human teammates and mentors are invaluable for your development. Don’t hesitate to ask a senior developer *why* they prefer one solution over another, especially if it differs from what an AI suggested. Discuss design decisions and trade-offs with more experienced colleagues – these conversations reveal how seasoned engineers think, and that’s gold for you. In code reviews, be extra receptive to comments about your AI-written code. If a reviewer points out that “this function isn’t thread-safe” or “this approach will have scaling issues,” take the time to understand the root issue. These are exactly the kind of things an AI might miss and you want to learn to catch. Over time, you’ll build a mental checklist of considerations. Additionally, find opportunities to pair program \(even if remotely\). Perhaps you can “pair” with a senior who uses AI in their workflow – you’ll observe how they prompt the AI and how they correct it. Being open to feedback and actively *asking* for guidance will help you mature from doing tasks that an AI could do to doing the high-value tasks that only humans can do. In a sense, you’re trying to acquire the wisdom that usually comes with experience, as efficiently as you can. That makes you more than just another coder in the room – it makes you the kind of engineer teams are eager to keep and promote.  
  **寻求反馈和指导：** 最后，一项可以加速您成长的持久技能是**寻求反馈**和向他人学习的能力。如果您忽略了人工智能的建议，它不会生气，但您的人类队友和导师对您的发展来说是无价的。不要犹豫，向高级开发人员询问*为什么*他们更喜欢一种解决方案而不是另一种解决方案，特别是当它与人工智能建议的不同时。与更有经验的同事讨论设计决策和权衡——这些对话揭示了经验丰富的工程师的想法，这对您来说是宝贵的。在代码审查中，要特别接受有关您的人工智能编写的代码的评论。如果审阅者指出“此功能不是线程安全的”或“这种方法会有扩展问题”，请花时间了解根本问题。这些正是人工智能可能会错过的东西，而您想要学会捕捉到。随着时间的推移，您将在脑海中建立一个考虑事项清单。此外，寻找配对编程的机会（即使是远程的）。也许你可以与一位在工作流程中使用人工智能的资深人士“结对”——你会观察他们如何提示人工智能以及如何纠正它。乐于接受反馈并积极*寻求*指导将帮助你从完成人工智能可以完成的任务成长为完成只有人类才能完成的高价值任务。从某种意义上说，你正在尽可能高效地尝试获取通常来自经验的智慧。这让你不仅仅是房间里的另一位程序员——它让你成为团队渴望留住和提拔的那种工程师。

It’s worth noting a mindset shift for juniors in the AI era: move from just *consuming solutions* to *creating understanding*. In the past, a junior might struggle through documentation and eventually write a feature; now an AI can hand you a solution on a platter. If you simply consume it \(copy-paste and move on\), you haven’t grown much.  
值得注意的是，人工智能时代的初级员工的思维模式发生了转变：从仅仅*使用解决方案*转变为*创造理解*。过去，初级员工可能会费力地阅读文档，最终编写出一个功能；现在，人工智能可以为你提供解决方案。如果你只是使用它（复制粘贴然后继续），那么你并没有成长多少。

Instead, use each AI-given solution as a **learning case**. Dissect it, experiment with it, and consider how you might have arrived at it yourself. By treating AI outputs not as answers to end all questions but as interactive learning material, you ensure that you – the human – are continuously leveling up. This way, rather than AI replacing your growth, it accelerates it. Many experts believe that while AI might reduce the need for large teams of junior “coder-grinders,” it also *raises the bar* for what it means to be a junior developer. The role is shifting to someone who can work effectively with AI and quickly climb the value chain. If you adopt the habits above, you’ll distinguish yourself as a junior developer who doesn’t just bring what an AI could bring \(any company can get that via a subscription\), but who brings insight, reliability, and continuous improvement – traits of a future senior developer.  
相反，将每个 AI 给出的解决方案作为一个**学习案例**。分析它，试验它，并思考你自己是如何得出这个结论的。通过将 AI 输出视为交互式学习材料而不是所有问题的答案，你可以确保你——人类——不断升级。这样，AI 不会取代你的成长，而是会加速你的成长。许多专家认为，虽然 AI 可能会减少对大型初级“编码员”团队的需求，但它也*提高了初级开发人员的标准*。这个角色正在转移到能够有效使用 AI 并快速攀登价值链的人身上。如果你养成上述习惯，你将成为一名初级开发人员，你不仅能带来 AI 可以带来的东西（任何公司都可以通过订阅获得），还能带来洞察力、可靠性和持续改进——这些都是未来高级开发人员的特质。

Software engineering has always been a field of continuous change – from assembly language to high-level programming, from on-prem servers to the cloud, and now from manual coding to AI-assisted development. Each leap has automated some aspect of programming, **yet each time developers have adapted and found even more to do**. As Tim O’Reilly notes, past innovations “almost always resulted in more work, more growth, more opportunities” for developers. The rise of AI is no different. Rather than making developers irrelevant, it is reshaping the skillset needed to succeed. The mundane 70% of coding is getting easier; the challenging 30% becomes an even larger part of our value.  
软件工程一直是一个不断变化的领域——从汇编语言到高级编程，从本地服务器到云，现在又从手动编码到人工智能辅助开发。每一次飞跃都使编程的某些方面实现了自动化，**但每次开发人员都会适应并发现更多事情要做**。正如 Tim O'Reilly 所说，过去的创新“几乎总是为开发人员带来更多工作、更多成长和更多机会”。人工智能的兴起也不例外。它并没有让开发人员变得无关紧要，而是重塑了成功所需的技能。70% 的平凡编码变得越来越容易；具有挑战性的 30% 成为我们价值的重要组成部分。

To maximize that human 30%, focus on the timeless engineering skills: understanding problems deeply, designing clean solutions, scrutinizing code for quality, and considering the users and context. Those who combine these skills with AI tools will outperform those who have only one or the other. In fact, the consensus emerging among experts is that **AI is a tool for the skilled**. Experienced programmers are gaining more from AI because they know how to guide it and what to do when it falters. It’s been said that  *“LLMs are power tools meant for power users.”* . This means the onus is on each of us to become that “power user” – to cultivate the expertise that lets us wield these new tools effectively.  
为了最大限度地发挥那 30% 的人力，需要专注于永恒的工程技能：深入理解问题、设计清晰的解决方案、仔细检查代码质量以及考虑用户和上下文。将这些技能与 AI 工具相结合的人将比只拥有其中一种技能的人表现更好。事实上，专家们正在达成的共识是， **AI 是技术娴熟的人的工具**。经验丰富的程序员从 AI 中获益更多，因为他们知道如何引导它，以及当它出现问题时该怎么做。有人说，  *“LLMs 是为高级用户设计的强大工具”*  。这意味着我们每个人都有责任成为那个“高级用户”——培养让我们有效使用这些新工具的专业知识。

Ultimately, the craft of software engineering is more than writing code that works. It’s about writing code that *works well* – in a real-world environment, over time, and under evolving requirements. Today’s AI can assist with writing code, but it cannot yet ensure the code works well in all those dimensions. That’s the developer’s job.  
归根结底，软件工程的技艺不只是编写能运行的代码。它还涉及编写*运行良好的*代码——在现实环境中、随着时间的推移和不断变化的需求下。当今的人工智能可以协助编写代码，但它还不能确保代码在所有这些方面都能很好地运行。这是开发人员的工作。

By doubling down on the skills outlined above, senior developers can continue to lead and innovate, and junior developers can accelerate their journey to mastery. AI will handle more and more of the routine, but your creativity, intuition, and thoughtful engineering will turn that raw output into something truly valuable. *AI is a powerful tool, but it’s all about how we use it.*  Good engineering practices, human judgment, and a willingness to learn will remain **essential**.  
通过加倍培养上述技能，高级开发人员可以继续领导和创新，初级开发人员可以加速他们的精通之旅。人工智能将处理越来越多的日常工作，但你的创造力、直觉和深思熟虑的工程将把这些原始输出变成真正有价值的东西。*人工智能是一个强大的工具，但关键在于我们如何使用它。* 良好的工程实践、人类判断力和学习意愿仍将**至关重要**。

In practical terms, whether you are pair-programming with an “eager junior” AI that writes your functions, or reviewing a diff full of AI-generated code, never forget to apply your uniquely human lens. Ask: Does this solve the *right* problem? Will others be able to understand and maintain this? What are the risks and edge cases? Those questions are your responsibility. The future of programming will indeed involve less typing every semicolon by hand and more directing and curating – but it will still require **developers** at the helm who have the wisdom to do it right.  
从实际角度来看，无论是与编写函数的“热切初级”AI 结对编程，还是审查充满 AI 生成代码的差异，都不要忘记运用您独特的人类视角。问问自己：这解决了*正确的*问题吗？其他人能够理解和维护这一点吗？风险和极端情况是什么？这些问题是您的责任。编程的未来确实将减少手动输入每个分号，而增加指导和策划——但它仍然需要有智慧的**开发人员**掌舵，以正确行事。

**Actionable takeaways:可操作的建议：**

* **Adopt a growth mindset with AI:**  Use it to amplify productivity, but commit to learning *why* solutions work. Treat AI as a partner, not a crutch, and regularly challenge yourself to work through problems without it to build your skills.  
  **以成长心态对待人工智能：** 利用人工智能来提高生产力，但要致力于了解解决方案*为何*有效。将人工智能视为合作伙伴，而不是拐杖，并定期挑战自己，在不使用人工智能的情况下解决问题，以培养自己的技能。
* **Invest in core skills:**  Sharpen your ability to design systems, think through edge cases, write tests, and debug deeply. These are long-term career skills that AI can’t substitute. Make code quality and clarity your personal mission on every task.  
  **投资核心技能：** 提高设计系统、思考极端情况、编写测试和深入调试的能力。这些是人工智能无法替代的长期职业技能。让代码质量和清晰度成为您每项任务的个人使命。
* **For senior devs:**  Leverage your experience to guide AI \(through good prompts\) and to vet its outputs. Take the lead in integrating AI into your team’s workflow responsibly – set standards for usage and ensure knowledge is shared. Use the time saved by AI to tackle more ambitious projects and to mentor others.  
  **对于高级开发人员：** 利用您的经验来指导 AI（通过良好的提示）并审查其输出。带头负责任地将 AI 集成到团队的工作流程中 - 设定使用标准并确保知识共享。利用 AI 节省的时间来处理更雄心勃勃的项目并指导他人。
* **For junior devs:**  Focus on becoming the kind of engineer who understands and can improve the code that AI generates. Build a reputation for thoroughness – always test and double-check your work. Learn from every bug and feedback. By doing so, you’ll quickly move into work that AI alone can’t do, increasing your value.  
  **对于初级开发人员：** 专注于成为能够理解并改进 AI 生成的代码的工程师。树立严谨的声誉——始终测试并仔细检查您的工作。从每个错误和反馈中学习。通过这样做，您将很快从事 AI 无法独自完成的工作，从而提高您的价值。
* **Stay adaptive:**  The tools will keep evolving. Continuously update your toolset and skills. But if you have solid fundamentals and a collaborative attitude, you’ll be able to ride any wave of technology.  
  **保持适应性：** 工具会不断发展。不断更新您的工具集和技能。但如果您拥有扎实的基础和协作态度，您将能够驾驭任何技术浪潮。

The era of AI-assisted coding is here, and it’s making routine coding faster. This frees us, as developers, to concentrate on the harder and more meaningful aspects of software creation. By maximizing our focus on that “last 30%” – the critical thinking, the design finesse, the quality checks – we ensure not only our relevance, but also that we deliver better software.  
人工智能辅助编码的时代已经到来，它让日常编码变得更快。这让我们这些开发人员可以专注于软件开发中更难、更有意义的方面。通过最大限度地关注“最后 30%”——批判性思维、设计技巧、质量检查——我们不仅可以确保我们的相关性，还可以提供更好的软件。

**In the end, great software engineering has always been about problem-solving, not just code-slinging. AI doesn’t change that - it simply challenges us to elevate our problem-solving to the next level. Embrace that challenge, and you’ll thrive in this new chapter of our industry.归根结底，伟大的软件工程始终是解决问题，而不仅仅是编写代码。人工智能不会改变这一点 - 它只是挑战我们将解决问题的能力提升到一个新的水平。接受这一挑战，您将在我们行业的新篇章中茁壮成长。**

![](https://substack-post-media.s3.amazonaws.com/public/images/8058b4d4-6df8-4f2c-a81e-c06ba62d3361_5248x3200.jpeg)
